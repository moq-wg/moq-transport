<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol.
Media is split into segments based on the underlying media encoding.
Each segment is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="segments"/> covers how media is encoded and split into segments.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media segments in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over the network somewhat independently.</t>

<t><list style="symbols">
  <t>The encoder determines how to fragment the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstreams are fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.
See the appendix for an overview of media encoding (<xref target="appendix.encoding"/>).</t>

<t>Warp works by fragmenting the bitstream into segments that can be transmitted independently.
Depending on how the segments are fragmented, the decoder has the ability to safely drop media during congestion.
See the appendix for fragmentation examples (<xref target="appendix.examples"/>)</t>

<t>A segment:</t>

<t><list style="symbols">
  <t>MUST contain a single track.</t>
  <t>MUST be in decode order. This means an increasing DTS.</t>
  <t>MAY contain any number of frames/samples.</t>
  <t>MAY have gaps between frames/samples.</t>
  <t>MAY overlap with other segments. This means interleaved timestamps.</t>
  <t>MAY reference frames in other segments, but only if listed as a dependency.</t>
</list></t>

<t>Segments are encoded using fragmented MP4 <xref target="ISOBMFF"/>.
This is necessary to store timestamps and various metadata depending on the codec.
A future draft of Warp may specify other container formats.</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>The encoder determines how to behave during congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>A sender MUST send each segment over a dedicated QUIC stream.
The QUIC library should support prioritization (<xref target="prioritization"/>) such that streams are transmitted in delivery order.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:</t>

<t><list style="symbols">
  <t>Newly encoded segments MAY have a smaller delivery order than outstanding segments.</t>
  <t>Packet loss or flow control MAY delay the delivery of individual streams.</t>
  <t>The sender might not support QUIC stream prioritization.</t>
</list></t>

<t>A proxy MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.
This is NOT RECOMMENDED unless the proxy knows additional information about the media.
For example, a proxy could use the PTS as the delivery order to enable head-of-line blocking for content that should not be skipped, like an advertisement.</t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel and out of order.</t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the latency.</t>

<t>Segments MUST synchronize segments using presentation timestamps within the bitstream.
Segments are NOT REQUIRED to be aligned and the decoder MUST be prepared to skip over any gaps.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message that indicates how the stream should be transmitted.</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The encoder may assign a numeric delivery order to each stream (<xref target="delivery-order"/>)
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending priority order.
The sender SHOULD prioritize streams based on the delivery order.
If two streams have the same delivery order, they SHOULD receive equal bandwidth (round-robin).</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
In order to support prioritization, a QUIC library MUST expose a API to set the priority of each stream.
This is easy to implement; the next QUIC packet should contain a STREAM frame for the next pending stream in priority order.
It is OPTIONAL to prioritize retransmissions within flow control limits.</t>

<t>The delivery order is written on the wire so it can be easily parsed by proxies.
A proxy SHOULD obey the stream priority.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer <xref target="QUIC-RECOVERY"/>.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat (ex. <xref target="BBR"/>).
It is NOT RECOMMENDED to use a loss-based algorithm (ex. <xref target="NewReno"/>) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>SEGMENT <xref target="segment"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains information required to deliver, cache, and forward a stream.
This message SHOULD be parsed and obeyed by any Warp proxies.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An unique identifier for the stream.
This field is optional and MUST be unique if set.</t>
  <t><spanx style="verb">order</spanx>.
An integer indicating the delivery order (<xref target="delivery-order"/>).
A sender SHOULD transmit streams with smallest value first, as bandwidth permits.
If two streams use the same value, they SHOULD be allocated the same bandwidth (round-robin).
Note that streams can still arrive out of the intended order due to packet loss.
This field is optional and the default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An list of dependencies by stream identifier.
The decoder SHOULD process the specified dependencies first.
The decoder MAY support stream processing via the decode timestamp (DTS), such that it does not need to fully receive the dependency segments first.
The segment SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
This field is optional.</t>
</list></t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of a segment in a fragmented MP4 container.</t>

<t>Each segment MUST start with an initialization fragment, or MUST depend on a segment with an initialization fragment.
An initialization fragment consists of a File Type Box (ftyp) followed by a Movie Box (moov).
This Movie Box (moov) consists of Movie Header Boxes (mvhd), Track Header Boxes (tkhd), Track Boxes (trak), followed by a final Movie Extends Box (mvex).
These boxes MUST NOT contain any samples and MUST have a duration of zero.
Note that a Common Media Application Format Header <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Each segment MAY have a Segment Type Box (styp) followed by any number of media fragments.
Each media fragment consists of a Movie Fragment Box (moof) followed by a Media Data Box (mdat).
The Media Fragment Box (moof) MUST contain a Movie Fragment Header Box (mfhd) and Track Box (trak) with a Track ID (<spanx style="verb">track_ID</spanx>) matching a Track Box in the initialization fragment.
Note that a Common Media Application Format Segment <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Media fragments can be packaged at any frequency, causing a trade-off between overhead and latency.
It is RECOMMENDED that a media fragment consists of a single frame to minimize latency.</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
The server MAY be a producer or consumer.</t>

<t>The server:</t>

<t><list style="symbols">
  <t>MAY initiate a graceful shutdown by sending a GOAWAY message.</t>
  <t>MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).</t>
  <t>MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.</t>
  <t>SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>
</list></t>

<t>The client:</t>

<t><list style="symbols">
  <t>MUST establish a new WebTransport session to the provided URL upon receipt of a <spanx style="verb">GOAWAY</spanx> message.</t>
  <t>SHOULD establish the connection in parallel which MUST use different QUIC connection.</t>
  <t>SHOULD remain connected for two servers for a short period, processing segments from both in parallel.</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.encoding" title="Appendix A. Video Encoding">
<t>In order to transport media, we first need to know how media is encoded.
This section is an overview of media encoding.</t>

<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Tracks can be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so this is not allowed.
Each Warp segment MUST contain a single track.</t>

</section>
<section anchor="appendix.init" title="Init">
<t>Media codecs have a wide array of configuration options.
For example, the resolution, the color space, the features enabled, etc.</t>

<t>Before playback can begin, the decoder needs to know how the configuration.
This is done via a short payload at the very start of the media file.
The initialization payload can be cached and reused between segments with the same configuration.</t>

</section>
<section anchor="appendix.video" title="Video">
<t>Video is a sequence of pictures (frames) with a presentation timestamp (PTS).</t>

<t>An I-frame is a frame with no dependencies and is effectively an image file.
These frames are usually inserted at a frequent interval to support seeking or joining a live stream.
However they can also improve compression when used at hard scene cuts.</t>

<t>A P-frame is a frame that references on one or more earlier frames.
These frames are delta-encoded, such that they only encode the changes (typically motion).
This result in a massive file size reduction for most content outside of few notorious cases (ex. confetti).</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency can avoid reference frames to allow more to be dropped.</t>

<section anchor="appendix.b-frame" title="B-Frames">
<t>The goal of video codecs is to maximize compression.
One of the improvements is to allow a frame to reference later frames.</t>

<t>A B-frame is a frame that can reference one or more frames in the future, and any number of frames in the past.
These frames are more difficult to encode/decode as they require buffering and reordering.</t>

<t>A common encoding structure is to use B-frames in a fixed pattern.
Such a fixed pattern is not optimal, but it's simpler for hardware encoding:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its references.
This makes it easier for the decoder as all references are earlier in the bitstream and can be decoded immediately.</t>

<t>However, this causes problems with B-frames because they depend on a future frame, and some reordering has to occur.
In order to keep track of this, frames have a decode timestamp (DTS) in addition to a presentation timestamp (PTS).
A B-frame will have higher DTS value that its dependencies, while PTS and DTS will be the same for other frame types.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
PTS: I B P B P I B P B P B
DTS: I   PB  PBI   PB  PB
]]></artwork></figure>

<t>B-frames add latency because of this reordering so they are usually not used for conversational latency.</t>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is an I-frame followed by any number of frames until the next I-frame.
All frames MUST reference, either directly or indirectly, only the most recent I-frame.</t>

<figure><artwork><![CDATA[
        GoP               GoP            GoP
+-----------------+-----------------+---------------
|     B     B     |     B     B     |     B
|    / \   / \    |    / \   / \    |    / \
|   v   v v   v   |   v   v v   v   |   v   v
|  I <-- P <-- P  |  I <-- P <-- P  |  I <-- P ...
+-----------------+-----------------+--------------
]]></artwork></figure>

<t>This is a useful abstraction because GoPs can always be decoded independently.</t>

</section>
<section anchor="appendix.svc" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This layered coding means that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
      +-------------------------+------------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P ...
      +-------------------------+------------------
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.audio" title="Audio">
<t>Audio is dramatically simpler than video as it is not typically delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>The encoder spits out a continuous stream of samples (S):</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S ...
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.examples" title="Appendix B. Segment Examples">
<t>Warp offers a large degree of flexability on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of some options available.</t>

<section anchor="video" title="Video">

<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and all frames that directly or indirectly reference it (<xref target="appendix.gop"/>).
The tail of a GoP can be dropped without causing decode errors, even if the encoding is otherwise unknown, making this the safest option.</t>

<t>It is RECOMMENDED that each segment consist of a single GoP.
For example:</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

<t>Depending on the video encoding, this approach may introduce unnecessary ordering and dependencies.
A better option may be available below.</t>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy (<xref target="appendix.svc"/>).</t>

<t>When SVC is used, it is RECOMMENDED that each segment consist of a single layer and GoP.
For example:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the encoder MAY can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>For example, we could split our example B-frame structure (<xref target="appendix.b-frame"/>) into 13 segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, segments can be merged with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

</section>
<section anchor="init" title="Init">
<t>Initialization data (<xref target="appendix.init"/>) is required to initialize the decoder.
Each segment MAY start with initialization data although this adds overhead.</t>

<t>Instead, it is RECOMMENDED to create a init segment.
Each media segment can then depend on the init segment to avoid the redundant overhead.
For example:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 5
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|              init             |  init
+-------------------------------+---------
             segment 1           segment 4
]]></artwork></figure>

</section>
</section>
<section anchor="audio" title="Audio">
<t>Audio (<xref target="appendix.audio"/>) is much simpler than video so there's fewer options.</t>

<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

<t>Since video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
<section anchor="appendix.delivery-order" title="Delivery Order">
<t>The delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>The delivery order may be changed if the content changes.
For example, switching from a live stream (skippable) to an advertisement (unskippable).</t>

</section>
</section>
<section numbered="false" anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Alan Frindell</t>
  <t>Charles Krasic</t>
  <t>Cullen Jennings</t>
  <t>James Hurley</t>
  <t>Jordi Cenzano</t>
  <t>Mike English</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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
hgAA

-->

</rfc>

