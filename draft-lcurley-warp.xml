<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol over QUIC.
Media is split into segments based on the underlying media encoding and transmitted independently over QUIC streams.
QUIC streams are prioritized based on the delivery order, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><list style="symbols">
  <t><xref target="motivation"/> covers the background and rationale behind Warp.</t>
  <t><xref target="segments"/> covers how media is encoded and split into segments.</t>
  <t><xref target="quic"/> covers how QUIC is used to transfer media.</t>
  <t><xref target="messages"/> covers how messages are encoded on the wire.</t>
</list></t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media encoded at a higher bitrate than the network can support causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and if necessary, bypass the queue entirely by dropping content.</t>

<t>The speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see usage at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are often radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided relays are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

<t>A related goal is to not reinvent how media is encoded.
The same codec bitstream and container should be usable between different protocols.</t>

</section>
<section anchor="relays" title="Relays">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The ability to scale a media protocol actually depends on relay support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>It's difficult to build a CDN for media protocols that were not designed with relays in mind.
For example, an relay has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.
This is the fatal flaw of many UDP-based protocols.</t>

<t>A goal of this draft is to treat relays as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in a header that is easy to parse.
This ensures that relays can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over QUIC streams.</t>

<t><list style="symbols">
  <t>The encoder determines how to fragment the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The decoder processes the codec bitstreams in the same order they were produced, with some possible exceptions based on the encoding.
See the appendix for an overview of media encoding (<xref target="appendix.encoding"/>).</t>

<t>Warp works by fragmenting the bitstream into segments that can be transmitted somewhat independently.
Depending on how the segments are fragmented, the decoder has the ability to safely drop media during congestion.
See the appendix for fragmentation examples (<xref target="appendix.examples"/>)</t>

<t>A segment:</t>

<t><list style="symbols">
  <t>MUST contain a single track.</t>
  <t>MUST be in decode order. This means an increasing DTS.</t>
  <t>MAY contain any number of frames/samples.</t>
  <t>MAY have gaps between frames/samples.</t>
  <t>MAY overlap with other segments. This means timestamps may be interleaved between segments.</t>
  <t>MAY reference frames in other segments, but only if listed as a dependency.</t>
</list></t>

<t>Segments are encoded using fragmented MP4 <xref target="ISOBMFF"/>.
This is necessary to store timestamps and various metadata depending on the codec.
A future draft of Warp may specify other container formats.</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>The encoder determines how to behave during congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>A sender MUST send each segment over a dedicated QUIC stream.
The QUIC library should support prioritization (<xref target="prioritization"/>) such that streams are transmitted in delivery order.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:</t>

<t><list style="symbols">
  <t>Newly encoded segments MAY have a smaller delivery order than outstanding segments.</t>
  <t>Packet loss or flow control MAY delay the delivery of individual streams.</t>
  <t>The sender might not support QUIC stream prioritization.</t>
</list></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel and out of order.</t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the end-to-end latency.</t>

<t>Segments MUST synchronize frames within and between tracks using presentation timestamps within the container.
Segments are NOT REQUIRED to be aligned and the decoder MUST be prepared to skip over any gaps.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication.
For example, including a authentication token and some identifier in the path.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>) to indicates how the stream should be transmitted.</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The encoder may assign a numeric delivery order to each stream (<xref target="delivery-order"/>)
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending priority order.
The sender SHOULD prioritize streams based on the delivery order.
If two streams have the same delivery order, they SHOULD receive equal bandwidth (round-robin).</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
In order to support prioritization, a QUIC library MUST expose a API to set the priority of each stream.
This is relatively easy to implement; the next QUIC packet should contain a STREAM frame for the next pending stream in priority order.</t>

<t>The sender MUST respect flow control even if means delivering streams out of delivery order.
It is OPTIONAL to prioritize retransmissions.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>A QUIC stream MAY be canceled at any point with an error code.
The producer does this via a <spanx style="verb">RESET_STREAM</spanx> frame while the consumer requests cancelation with a <spanx style="verb">STOP_SENDING</spanx> frame.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>The sender MAY cancel streams in response to congestion.
This can be useful when the sender does not support stream prioritization.</t>

</section>
<section anchor="relays-1" title="Relays">
<t>Warp encodes the delivery information for each stream via a <spanx style="verb">HEADERS</spanx> frame (<xref target="headers"/>).
This MUST be at the start of each stream so it is easy for a relay to parse.</t>

<t>A relay SHOULD prioritize streams (<xref target="prioritization"/>) based on the delivery order.
A relay MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.</t>

<t>A relay that reads from a stream and then writes to another stream will suffer from head-of-line blocking.
Packet loss will cause stream data to be buffered in the QUIC library, awaiting an in order flush, which will increase latency over additional hops.
To mitigate this, a relay SHOULD read and write QUIC streams out of order according to flow control limits.
See section 2.2 in <xref target="QUIC"/>.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer <xref target="QUIC-RECOVERY"/>.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat (ex. <xref target="BBR"/>).
It is NOT RECOMMENDED to use a loss-based algorithm (ex. <xref target="NewReno"/>) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY (<xref target="goaway"/>)</c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS (<xref target="headers"/>)</c>
      <c>0x1</c>
      <c>SEGMENT (<xref target="segment"/>)</c>
      <c>0x2</c>
      <c>APP (<xref target="app"/>)</c>
      <c>0x10</c>
      <c>GOAWAY (<xref target="goaway"/>)</c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains information required to deliver, cache, and forward a stream.
This message SHOULD be parsed and obeyed by any Warp relays.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An unique identifier for the stream.
This field is optional and MUST be unique if set.</t>
  <t><spanx style="verb">order</spanx>.
An integer indicating the delivery order (<xref target="delivery-order"/>).
This field is optional and the default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An list of dependencies by stream identifier.
The decoder SHOULD process the specified dependencies first.
The decoder MAY support stream processing via the decode timestamp (DTS), such that it does not need to fully receive the dependency segments first.
The segment SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
This field is optional.</t>
</list></t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of a segment in a fragmented MP4 container.</t>

<t>Each segment MUST start with an initialization fragment, or MUST depend on a segment with an initialization fragment.
An initialization fragment consists of a File Type Box (ftyp) followed by a Movie Box (moov).
This Movie Box (moov) consists of Movie Header Boxes (mvhd), Track Header Boxes (tkhd), Track Boxes (trak), followed by a final Movie Extends Box (mvex).
These boxes MUST NOT contain any samples and MUST have a duration of zero.
Note that a Common Media Application Format Header <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Each segment MAY have a Segment Type Box (styp) followed by any number of media fragments.
Each media fragment consists of a Movie Fragment Box (moof) followed by a Media Data Box (mdat).
The Media Fragment Box (moof) MUST contain a Movie Fragment Header Box (mfhd) and Track Box (trak) with a Track ID (<spanx style="verb">track_ID</spanx>) matching a Track Box in the initialization fragment.
Note that a Common Media Application Format Segment <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Media fragments can be packaged at any frequency, causing a trade-off between overhead and latency.
It is RECOMMENDED that a media fragment consists of a single frame to minimize latency.</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
This is useful for metadata that would otherwise have to be shoved into the media bitstream.</t>

<t>Relays MUST NOT differentiate between streams containing <spanx style="verb">SEGMENT</spanx> and <spanx style="verb">APP</spanx> frames.
The same forwarding and caching behavior applies to both as specified in the<spanx style="verb">HEADERS</spanx> frame.</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
The server MAY be a producer or consumer.</t>

<t>The server:</t>

<t><list style="symbols">
  <t>MAY initiate a graceful shutdown by sending a GOAWAY message.</t>
  <t>MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).</t>
  <t>MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.</t>
  <t>SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>
</list></t>

<t>The client:</t>

<t><list style="symbols">
  <t>MUST establish a new WebTransport session to the provided URL upon receipt of a <spanx style="verb">GOAWAY</spanx> message.</t>
  <t>SHOULD establish the connection in parallel which MUST use different QUIC connection.</t>
  <t>SHOULD remain connected for two servers for a short period, processing segments from both in parallel.</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion.
The producer and consumer MUST cancel a stream, preferrably the lowest priority, after reaching a resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.encoding" title="Appendix A. Video Encoding">
<t>In order to transport media, we first need to know how media is encoded.
This section is an overview of media encoding.</t>

<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Tracks can be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so this is not allowed.
Each Warp segment MUST contain a single track.</t>

</section>
<section anchor="appendix.init" title="Init">
<t>Media codecs have a wide array of configuration options.
For example, the resolution, the color space, the features enabled, etc.</t>

<t>Before playback can begin, the decoder needs to know the configuration.
This is done via a short payload at the very start of the media file.
The initialization payload MAY be cached and reused between segments with the same configuration.</t>

</section>
<section anchor="appendix.video" title="Video">
<t>Video is a sequence of pictures (frames) with a presentation timestamp (PTS).</t>

<t>An I-frame is a frame with no dependencies and is effectively an image file.
These frames are usually inserted at a frequent interval to support seeking or joining a live stream.
However they can also improve compression when used at scene boundaries.</t>

<t>A P-frame is a frame that references on one or more earlier frames.
These frames are delta-encoded, such that they only encode the changes (motion).
This result in a massive file size reduction for most content outside of few notorious cases (ex. confetti).</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency can avoid reference frames to allow more to be dropped.</t>

<section anchor="appendix.b-frame" title="B-Frames">
<t>The goal of video codecs is to maximize compression.
One of the improvements is to allow a frame to reference later frames.</t>

<t>A B-frame is a frame that can reference one or more frames in the future, and any number of frames in the past.
These frames are more difficult to encode/decode as they require buffering and reordering.</t>

<t>A common encoding structure is to use B-frames in a fixed pattern.
Such a fixed pattern is not optimal, but it's simpler for hardware encoding:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

</section>
<section anchor="timestamps" title="Timestamps">
<t>Each frame is assigned a presentation timestamp (PTS), indicating when it should be shown relative to other frames.</t>

<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its references.
This makes it easier for the decoder as all references are earlier in the bitstream and can be decoded immediately.</t>

<t>However, this causes problems with B-frames because they depend on a future frame, and some reordering has to occur.
In order to keep track of this, frames have a decode timestamp (DTS) in addition to a presentation timestamp (PTS).
A B-frame will have higher DTS value that its dependencies, while PTS and DTS will be the same for other frame types.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
     0 1 2 3 4 5 6 7 8 9 10
PTS: I B P B P I B P B P B
DTS: I   PB  PBI   PB  PB
]]></artwork></figure>

<t>B-frames add latency because of this reordering so they are usually not used for conversational latency.</t>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is an I-frame followed by any number of frames until the next I-frame.
All frames MUST reference, either directly or indirectly, only the most recent I-frame.</t>

<figure><artwork><![CDATA[
        GoP               GoP            GoP
+-----------------+-----------------+---------------
|     B     B     |     B     B     |     B
|    / \   / \    |    / \   / \    |    / \
|   v   v v   v   |   v   v v   v   |   v   v
|  I <-- P <-- P  |  I <-- P <-- P  |  I <-- P ...
+-----------------+-----------------+--------------
]]></artwork></figure>

<t>This is a useful abstraction because GoPs can always be decoded independently.</t>

</section>
<section anchor="appendix.svc" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This layered coding means that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
      +-------------------------+------------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P ...
      +-------------------------+------------------
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.audio" title="Audio">
<t>Audio is dramatically simpler than video as it is not typically delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>The encoder spits out a continuous stream of samples (S):</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S ...
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.examples" title="Appendix B. Segment Examples">
<t>Warp offers a large degree of flexability on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of some options available.</t>

<section anchor="video" title="Video">

<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and all frames that directly or indirectly reference it (<xref target="appendix.gop"/>).
The tail of a GoP can be dropped without causing decode errors, even if the encoding is otherwise unknown, making this the safest option.</t>

<t>It is RECOMMENDED that each segment consist of a single GoP.
For example:</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

<t>Depending on the video encoding, this approach may introduce unnecessary ordering and dependencies.
A better option may be available below.</t>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy (<xref target="appendix.svc"/>).</t>

<t>When SVC is used, it is RECOMMENDED that each segment consist of a single layer and GoP.
For example:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the encoder MAY can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>For example, we could split our example B-frame structure (<xref target="appendix.b-frame"/>) into 13 segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, segments can be merged with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

</section>
<section anchor="init" title="Init">
<t>Initialization data (<xref target="appendix.init"/>) is required to initialize the decoder.
Each segment MAY start with initialization data although this adds overhead.</t>

<t>Instead, it is RECOMMENDED to create a init segment.
Each media segment can then depend on the init segment to avoid the redundant overhead.
For example:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 5
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|              init             |  init
+-------------------------------+---------
             segment 1           segment 4
]]></artwork></figure>

</section>
</section>
<section anchor="audio" title="Audio">
<t>Audio (<xref target="appendix.audio"/>) is much simpler than video so there's fewer options.</t>

<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

<t>Since video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
<section anchor="appendix.delivery-order" title="Delivery Order">
<t>The delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>The delivery order may be changed if the content changes.
For example, switching from a live stream (skippable) to an advertisement (unskippable).</t>

</section>
</section>
<section numbered="false" anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Alan Frindell</t>
  <t>Charles Krasic</t>
  <t>Cullen Jennings</t>
  <t>James Hurley</t>
  <t>Jordi Cenzano</t>
  <t>Mike English</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
H4sIAEj/VmMAA9V963Yb15XmfzzFaflHxASAKcl2bDq9OrzJYkcXtkjHK6u7
l1UADogKC1VIXUjClrLmIeYB5lnmUeZJZn9773MrFCnLszIzzcQQUKg6l332
5duXczCZTEZt3hb2wDz6Ias3ZmIu7NXalq1dmJf5jTWv7CLPzGWdlc2mqttH
o2w2q+3Ngfnh8O35aFHNy2xNTy/qbNlOinlXF3Y7uaWmJkXW2qYdLeifA/Pz
yeHl6YfRnD5cVfX2wOTlshqN8k19YNq6a9qn+/vf7D8dZbXNDsx3trR1Voxu
q/r6qq66zYE5Kxd2Y+mlbM1FN1vnTZNX5ejabummBb5vbV3adnKCkYxGTZuV
ix+zoiqp961tRs06q9sf/9ZVNKoDU1ajTX5g/r2t5mPT0MRqu2zo3XYtb2hi
62yzycur/xyNsq5dVfXByJgJ/Wdo7NTCy6k55tnyJaHCy+7axler+ior85+y
loZ6YC5v83a+4i/sOsuLA3Od31mQafHHK1yYzqv1KO3lT1Nz3l3lZdTJn/I6
L4roctrLK9tmcR/5dV7/cU0XB1q/mJrXRKbsuiPiRF1cdKus6X+VdnOcN/Mq
7qcp5fY/zvGNdDYqq3pND9xYEO/fvj87PjBvnx9/s7+/r58nb0+P3/z59O1f
3BdP6Ysf7MwzHK3s5GSa23Y5ubWzFpcnq7bdPMNUzi7eHL16/vyAx+H4+Iw4
i3utStPa+aqsiupqa/7Xf/vv5rha0IqaammybpFXk5u86bLCVLO/2nnb8C3n
xCXmydMDtG2OssZJwPO8sOY5N/yIuxO+frr/5MvJk6fEya5Xmevxq8NfNqzJ
xLzqijZfcy/EckU+l5vkdvP41fnpd5PDPdwpg/uGqF+t13TL/Q+h/z18Mo2X
Z747HfzT/cn+M7ry2t6+tWXFi/DVl19jEY6O3grt51m9uLVFMcnn8/pqQuI/
mVflFck2dYi3bV0VE1q40WhCY8xmDa3SnETwcpU3EKQO/ZuFXealbUy7smZe
1dbM7Cq7yWmEGCWUz9hk0WgLaB+ZYOuYwWzqiiS2oiW7sTUz0HQk60NdNUSG
lhi7rVwzjZnRCi4MSE7ddqQ+6mILFpCGbTkXjiDWlV7WeYvO86Btim3ozNDU
bLZupqP4kyGlRSOjqeRt/hM9nXS6sJhJTa3U1DvNsSiqW/RZ2KYx+Rrzyog+
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
luEnpNIkqvYKWXLvK7px+QI6+bFEf6B3LoceNxY/nFRa5PG5cF5/ixMwNZOU
l4+xJz/hmf7mmH7ndpojZo9CBuJCPq9ZchIkWMzJm4rG1IOxY0k8A/26cxTd
b/cmjq1fggcXkTjh3ojgww/yImLHVyjOUOomu8LVRUgCo3pSuPuFIH8eKtP6
ig94b+MTeHq6nY+NzHjPitbl8raDZDM5kqQW50foPhIu8r5BAziFYPqPjSZd
mPj/937+5GiSbCJ023qi34r1J5w2yXGlY1cgyL/fhNuD9xQUGZ+5MXBog9en
9wiIuEj9jG+kri9y2H4NHwU4Iz9MxAhhd93cHkMNi45jMYd/x9rA/3J0pbtN
ZEDy+8GOrVyx3j1HLPrZYXtCQkbjAkwy8t087X0s83+i4/8BLPMPMRwP2bgv
4g9f+dxLeuZ5nD3obVoeOpV7YGvzfSH/fvZyp2afC7JzV5Aele2QPiH0etDv
+59RoDHwCPjwwccm/jk1Vf2u3OYe5rsDZb9eM3/Qh9PLoyEiacRXajMXLnLv
Siy1ZLPnADQkabLRQE9himpWzWMeJ1TInhzDRJrjRn6wTQ4v7spwB29MOHa/
R1TVzejnA/GU7OKfHy0J19tHH0ajiTksqKHnNbLqRUGfj1fkyZCu/1ONY2hx
oSsKMm3/aku4Uw1d+Vf2S150dN8WH3HukTm25U9ZWdHnV/m1NadkxfNmNfrf
f1SA9NeHAAA=

-->

</rfc>

