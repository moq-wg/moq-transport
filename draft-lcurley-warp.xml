<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol.
Media is split into segments based on the underlying media encoding.
Each segment is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="segments"/> covers how media is encoded and split into segments.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media segments in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over the network somewhat independently.</t>

<t><list style="symbols">
  <t>The encoder determines how to fragment the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstreams are fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.
See the appendix for an overview of media encoding (<xref target="appendix.encoding"/>).</t>

<t>Warp works by fragmenting the bitstream into segments that can be transmitted independently.
Depending on how the segments are fragmented, the decoder has the ability to safely drop media during congestion.
See the appendix for fragmentation examples (<xref target="appendix.examples"/>)</t>

<t>A segment:</t>

<t><list style="symbols">
  <t>MUST contain a single track.</t>
  <t>MUST be in decode order. This means an increasing DTS.</t>
  <t>MAY contain any number of frames/samples.</t>
  <t>MAY have gaps between frames/samples.</t>
  <t>MAY overlap with other segments. This means interleaved timestamps.</t>
  <t>MAY reference frames in other segments, but only if listed as a dependency.</t>
</list></t>

<t>Segments are encoded using fragmented MP4 <xref target="ISOBMFF"/>.
This is necessary to store timestamps and various metadata depending on the codec.
A future draft of Warp may specify other container formats.</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>Warp responds to congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>The encoder determines the value assigned to each segment based the media encoding and desired user experience.
Multiple segments MAY use the same value, in which case they SHOULD be delivered via round-robin.
See the appendix for examples (<xref target="appendix.examples"/>).</t>

<t>A sender SHOULD attempt to deliver segments based on this delivery order.
This effectively involves creating a priority queue in ascending order, allocating any avaiable bandwidth to the next pending segment.
Since each segment is sent over a dedicated QUIC stream, the next QUIC packet SHOULD contain a STREAM frame for the next pending segment, repeated until the congestion window is hit.
The sender MAY ignore the delivery order for retransmits and MUST ignore it when flow control limits are reached.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:</t>

<t><list style="symbols">
  <t>Newly encoded segments MAY have a smaller delivery order than outstanding segments.</t>
  <t>Packet loss or flow control MAY delay the delivery of individual streams.</t>
  <t>The sender might not support QUIC stream prioritization.</t>
</list></t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the latency.</t>

<t>A proxy MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.
This is NOT RECOMMENDED unless the proxy knows additional information about the media.
For example, a proxy could use the PTS as the delivery order to enable head-of-line blocking for content that should not be skipped, like an advertisement.</t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel.
The decoder MUST synchronize segments using presentation timestamps within the bitstream.
The decoder SHOULD use a buffer to reorder frames/samples from separate segments into decode order.</t>

<t>Segments are NOT REQUIRED to be aligned.
A decoder MUST be prepared to skip over any gaps between segments.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message that indicates how the stream should be transmitted.</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The delivery order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer <xref target="QUIC-RECOVERY"/>.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat (ex. <xref target="BBR"/>).
It is NOT RECOMMENDED to use a loss-based algorithm (ex. <xref target="NewReno"/>) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>SEGMENT <xref target="segment"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains information required to deliver, cache, and forward a stream.
This message SHOULD be parsed and obeyed by any Warp proxies.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An unique identifier for the stream.
This field is optional and MUST be unique if set.</t>
  <t><spanx style="verb">order</spanx>.
An numeric value indicating the delivery order (<xref target="delivery-order"/>).
A sender SHOULD transmit streams with smallest value first, as bandwidth permits.
If two streams use the same value, they SHOULD be round-robined.
Note that streams can still arrive out of the intended order due to packet loss.
This field is optional and the default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An list of dependencies by stream identifier.
The decoder SHOULD process the specified dependencies first.
The decoder MAY support stream processing via the decode timestamp (DTS), such that it does not need to fully receive the dependency segments first.
The segment SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
This field is optional.</t>
</list></t>

<t>TODO use QPACK?</t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of a segment in a fragmented MP4 container.</t>

<t>Each segment MUST start with an initialization fragment, or MUST depend on a segment with an initialization fragment.
An initialization fragment consists of a File Type Box (ftyp) followed by a Movie Box (moov).
This Movie Box (moov) consists of Movie Header Boxes (mvhd), Track Header Boxes (tkhd), Track Boxes (trak), followed by a final Movie Extends Box (mvex).
These boxes MUST NOT contain any samples and MUST have a duration of zero.
Note that a Common Media Application Format Header <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Each segment MAY have a Segment Type Box (styp) followed by any number of media fragments.
Each media fragment consists of a Movie Fragment Box (moof) followed by a Media Data Box (mdat).
The Media Fragment Box (moof) MUST contain a Movie Fragment Header Box (mfhd) and Track Box (trak) with a Track ID (<spanx style="verb">track_ID</spanx>) matching a Track Box in the initialization fragment.
Note that a Common Media Application Format Segment <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Media fragments can be packaged at any frequency, causing a trade-off between overhead and latency.
It is RECOMMENDED that a media fragment consists of a single frame to minimize latency.</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server:</t>

<t><list style="symbols">
  <t>MAY initiate a graceful shutdown by sending a GOAWAY message.</t>
  <t>MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).</t>
  <t>MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.</t>
  <t>SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>
</list></t>

<t>The client:</t>

<t><list style="symbols">
  <t>MUST establish a new WebTransport session to the provided URL upon receipt of a <spanx style="verb">GOAWAY</spanx> message.</t>
  <t>SHOULD establish the connection in parallel which MUST use different QUIC connection.</t>
  <t>SHOULD remain connected for two servers for a short period, processing segments from both in parallel.</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.encoding" title="Appendix A. Video Encoding">
<t>In order to transport media, we first need to know how media is encoded.
This section is an overview of media encoding.</t>

<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Tracks can be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so this is not allowed.
Each Warp segment MUST contain a single track.</t>

</section>
<section anchor="appendix.init" title="Init">
<t>Media codecs have a wide array of configuration options.
For example, the resolution, the color space, the features enabled, etc.</t>

<t>Before playback can begin, the decoder needs to know how the configuration.
This is done via a short payload at the very start of the media file.
The initialization payload can be cached and reused between segments with the same configuration.</t>

</section>
<section anchor="appendix.video" title="Video">
<t>Video is a sequence of pictures (frames) with a presentation timestamp (PTS).</t>

<t>An I-frame is a frame with no dependencies and is effectively an image file.
These frames are usually inserted at a frequent interval to support seeking or joining a live stream.
However they can also improve compression when used at hard scene cuts.</t>

<t>A P-frame is a frame that references on one or more earlier frames.
These frames are delta-encoded, such that they only encode the changes (typically motion).
This result in a massive file size reduction for most content outside of few notorious cases (ex. confetti).</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency can avoid reference frames to allow more to be dropped.</t>

<section anchor="appendix.b-frame" title="B-Frames">
<t>The goal of video codecs is to maximize compression.
One of the improvements is to allow a frame to reference later frames.</t>

<t>A B-frame is a frame that can reference one or more frames in the future, and any number of frames in the past.
These frames are more difficult to encode/decode as they require buffering and reordering.</t>

<t>A common encoding structure is to use B-frames in a fixed pattern.
Such a fixed pattern is not optimal, but it's simpler for hardware encoding:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its references.
This makes it easier for the decoder as all references are earlier in the bitstream and can be decoded immediately.</t>

<t>However, this causes problems with B-frames because they depend on a future frame, and some reordering has to occur.
In order to keep track of this, frames have a decode timestamp (DTS) in addition to a presentation timestamp (PTS).
A B-frame will have higher DTS value that its dependencies, while PTS and DTS will be the same for other frame types.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
PTS: I B P B P I B P B P B
DTS: I   PB  PBI   PB  PB
]]></artwork></figure>

<t>B-frames add latency because of this reordering so they are usually not used for conversational latency.</t>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is an I-frame followed by any number of frames until the next I-frame.
All frames MUST reference, either directly or indirectly, only the most recent I-frame.</t>

<figure><artwork><![CDATA[
        GoP               GoP            GoP
+-----------------+-----------------+---------------
|     B     B     |     B     B     |     B
|    / \   / \    |    / \   / \    |    / \
|   v   v v   v   |   v   v v   v   |   v   v
|  I <-- P <-- P  |  I <-- P <-- P  |  I <-- P ...
+-----------------+-----------------+--------------
]]></artwork></figure>

<t>This is a useful abstraction because GoPs can always be decoded independently.</t>

</section>
<section anchor="appendix.svc" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This layered coding means that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
      +-------------------------+------------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P ...
      +-------------------------+------------------
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.audio" title="Audio">
<t>Audio is dramatically simpler than video as it is not typically delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>The encoder spits out a continuous stream of samples (S):</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S ...
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.examples" title="Appendix B. Segment Examples">
<t>Warp offers a large degree of flexability on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of some options available.</t>

<section anchor="video" title="Video">

<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and all frames that directly or indirectly reference it (<xref target="appendix.gop"/>).
The tail of a GoP can be dropped without causing decode errors, even if the encoding is otherwise unknown, making this the safest option.</t>

<t>It is RECOMMENDED that each segment consist of a single GoP.
For example:</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

<t>Depending on the video encoding, this approach may introduce unnecessary ordering and dependencies.
A better option may be available below.</t>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy (<xref target="appendix.svc"/>).</t>

<t>When SVC is used, it is RECOMMENDED that each segment consist of a single layer and GoP.
For example:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the encoder MAY can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>For example, we could split our example B-frame structure (<xref target="appendix.b-frame"/>) into 13 segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, segments can be merged with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

</section>
<section anchor="init" title="Init">
<t>Initialization data (<xref target="appendix.init"/>) is required to initialize the decoder.
Each segment MAY start with initialization data although this adds overhead.</t>

<t>Instead, it is RECOMMENDED to create a init segment.
Each media segment can then depend on the init segment to avoid the redundant overhead.
For example:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 5
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|              init             |  init
+-------------------------------+---------
             segment 1           segment 4
]]></artwork></figure>

</section>
</section>
<section anchor="audio" title="Audio">
<t>Audio (<xref target="appendix.audio"/>) is much simpler than video so there's fewer options.</t>

<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

<t>Since video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
<section anchor="appendix.delivery-order" title="Delivery Order">
<t>The delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>The delivery order may be changed if the content changes.
For example, switching from a live stream (skippable) to an advertisement (unskippable).</t>

</section>
</section>
<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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
bvbPT+aA692TB94dPPgPaOab4kqJAAA=

-->

</rfc>

