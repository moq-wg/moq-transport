<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol.
Media is split into segments based on the underlying media encoding.
Each segment is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="segments"/> covers how media is encoded and split into segments.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media segments in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over the network somewhat independently.</t>

<t><list style="symbols">
  <t>The encoder determines how to fragment the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstreams are fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.
See the appendix for an overview of media encoding (<xref target="appendix.encoding"/>).</t>

<t>Warp works by fragmenting the bitstream into segments that can be transmitted independently.
Depending on how the segments are fragmented, the decoder has the ability to safely drop media during congestion.
See the appendix for fragmentation examples (<xref target="appendix.examples"/>)</t>

<t>A segment:</t>

<t><list style="symbols">
  <t>MUST contain a single track.</t>
  <t>MUST be in decode order. This means an increasing DTS.</t>
  <t>MAY contain any number of frames/samples.</t>
  <t>MAY have gaps between frames/samples.</t>
  <t>MAY overlap with other segments. This means interleaved timestamps.</t>
  <t>MAY reference frames in other segments, but only if listed as a dependency.</t>
</list></t>

<t>Segments are encoded using fragmented MP4 <xref target="ISOBMFF"/>.
This is necessary to store timestamps and various metadata depending on the codec.
A future draft of Warp may specify other container formats.</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>The encoder determines how to behave during congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>A sender MUST send each segment over a dedicated QUIC stream.
The QUIC library should support prioritization (<xref target="prioritization"/>) such that streams are transmitted in delivery order.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:</t>

<t><list style="symbols">
  <t>Newly encoded segments MAY have a smaller delivery order than outstanding segments.</t>
  <t>Packet loss or flow control MAY delay the delivery of individual streams.</t>
  <t>The sender might not support QUIC stream prioritization.</t>
</list></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel and out of order.</t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the latency.</t>

<t>Segments MUST synchronize segments using presentation timestamps within the bitstream.
Segments are NOT REQUIRED to be aligned and the decoder MUST be prepared to skip over any gaps.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message that indicates how the stream should be transmitted.</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The encoder may assign a numeric delivery order to each stream (<xref target="delivery-order"/>)
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending priority order.
The sender SHOULD prioritize streams based on the delivery order.
If two streams have the same delivery order, they SHOULD receive equal bandwidth (round-robin).</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
In order to support prioritization, a QUIC library MUST expose a API to set the priority of each stream.
This is easy to implement; the next QUIC packet should contain a STREAM frame for the next pending stream in priority order.
It is OPTIONAL to prioritize retransmissions within flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>A QUIC stream MAY be canceled at any point with an error code.
The producer does this via a <spanx style="verb">RESET_STREAM</spanx> frame while the consumer requests cancelation with a <spanx style="verb">STOP_SENDING</spanx> frame.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>The producer or consumer MAY cancel streams in response to congestion.
This can be useful when the sender does not support stream prioritization.</t>

</section>
<section anchor="relays" title="Relays">
<t>Warp encodes the delivery information at the start each stream via a <spanx style="verb">HEADERS</spanx> frame (<xref target="headers"/>).
This is meant to be easy to parse for a relay.</t>

<t>A relay SHOULD prioritize streams (<xref target="prioritization"/>) based on the delivery order.
A relay MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.</t>

<t>A relay that reads from a stream and then writes to another stream will suffer from head-of-line blocking.
Packet loss will cause stream data to be buffered in the QUIC library, awaiting an in order flush, which will increase latency over additional hops.
To mitigate this, a relay MAY read and write QUIC streams out of order according to flow control limits.
See section 2.2 in <xref target="QUIC"/>.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer <xref target="QUIC-RECOVERY"/>.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat (ex. <xref target="BBR"/>).
It is NOT RECOMMENDED to use a loss-based algorithm (ex. <xref target="NewReno"/>) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>SEGMENT <xref target="segment"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains information required to deliver, cache, and forward a stream.
This message SHOULD be parsed and obeyed by any Warp proxies.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An unique identifier for the stream.
This field is optional and MUST be unique if set.</t>
  <t><spanx style="verb">order</spanx>.
An integer indicating the delivery order (<xref target="delivery-order"/>).
A sender SHOULD transmit streams with smallest value first, as bandwidth permits.
If two streams use the same value, they SHOULD be allocated the same bandwidth (round-robin).
Note that streams can still arrive out of the intended order due to packet loss.
This field is optional and the default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An list of dependencies by stream identifier.
The decoder SHOULD process the specified dependencies first.
The decoder MAY support stream processing via the decode timestamp (DTS), such that it does not need to fully receive the dependency segments first.
The segment SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
This field is optional.</t>
</list></t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of a segment in a fragmented MP4 container.</t>

<t>Each segment MUST start with an initialization fragment, or MUST depend on a segment with an initialization fragment.
An initialization fragment consists of a File Type Box (ftyp) followed by a Movie Box (moov).
This Movie Box (moov) consists of Movie Header Boxes (mvhd), Track Header Boxes (tkhd), Track Boxes (trak), followed by a final Movie Extends Box (mvex).
These boxes MUST NOT contain any samples and MUST have a duration of zero.
Note that a Common Media Application Format Header <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Each segment MAY have a Segment Type Box (styp) followed by any number of media fragments.
Each media fragment consists of a Movie Fragment Box (moof) followed by a Media Data Box (mdat).
The Media Fragment Box (moof) MUST contain a Movie Fragment Header Box (mfhd) and Track Box (trak) with a Track ID (<spanx style="verb">track_ID</spanx>) matching a Track Box in the initialization fragment.
Note that a Common Media Application Format Segment <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Media fragments can be packaged at any frequency, causing a trade-off between overhead and latency.
It is RECOMMENDED that a media fragment consists of a single frame to minimize latency.</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
The server MAY be a producer or consumer.</t>

<t>The server:</t>

<t><list style="symbols">
  <t>MAY initiate a graceful shutdown by sending a GOAWAY message.</t>
  <t>MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).</t>
  <t>MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.</t>
  <t>SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>
</list></t>

<t>The client:</t>

<t><list style="symbols">
  <t>MUST establish a new WebTransport session to the provided URL upon receipt of a <spanx style="verb">GOAWAY</spanx> message.</t>
  <t>SHOULD establish the connection in parallel which MUST use different QUIC connection.</t>
  <t>SHOULD remain connected for two servers for a short period, processing segments from both in parallel.</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.encoding" title="Appendix A. Video Encoding">
<t>In order to transport media, we first need to know how media is encoded.
This section is an overview of media encoding.</t>

<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Tracks can be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so this is not allowed.
Each Warp segment MUST contain a single track.</t>

</section>
<section anchor="appendix.init" title="Init">
<t>Media codecs have a wide array of configuration options.
For example, the resolution, the color space, the features enabled, etc.</t>

<t>Before playback can begin, the decoder needs to know how the configuration.
This is done via a short payload at the very start of the media file.
The initialization payload can be cached and reused between segments with the same configuration.</t>

</section>
<section anchor="appendix.video" title="Video">
<t>Video is a sequence of pictures (frames) with a presentation timestamp (PTS).</t>

<t>An I-frame is a frame with no dependencies and is effectively an image file.
These frames are usually inserted at a frequent interval to support seeking or joining a live stream.
However they can also improve compression when used at hard scene cuts.</t>

<t>A P-frame is a frame that references on one or more earlier frames.
These frames are delta-encoded, such that they only encode the changes (typically motion).
This result in a massive file size reduction for most content outside of few notorious cases (ex. confetti).</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency can avoid reference frames to allow more to be dropped.</t>

<section anchor="appendix.b-frame" title="B-Frames">
<t>The goal of video codecs is to maximize compression.
One of the improvements is to allow a frame to reference later frames.</t>

<t>A B-frame is a frame that can reference one or more frames in the future, and any number of frames in the past.
These frames are more difficult to encode/decode as they require buffering and reordering.</t>

<t>A common encoding structure is to use B-frames in a fixed pattern.
Such a fixed pattern is not optimal, but it's simpler for hardware encoding:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its references.
This makes it easier for the decoder as all references are earlier in the bitstream and can be decoded immediately.</t>

<t>However, this causes problems with B-frames because they depend on a future frame, and some reordering has to occur.
In order to keep track of this, frames have a decode timestamp (DTS) in addition to a presentation timestamp (PTS).
A B-frame will have higher DTS value that its dependencies, while PTS and DTS will be the same for other frame types.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
PTS: I B P B P I B P B P B
DTS: I   PB  PBI   PB  PB
]]></artwork></figure>

<t>B-frames add latency because of this reordering so they are usually not used for conversational latency.</t>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is an I-frame followed by any number of frames until the next I-frame.
All frames MUST reference, either directly or indirectly, only the most recent I-frame.</t>

<figure><artwork><![CDATA[
        GoP               GoP            GoP
+-----------------+-----------------+---------------
|     B     B     |     B     B     |     B
|    / \   / \    |    / \   / \    |    / \
|   v   v v   v   |   v   v v   v   |   v   v
|  I <-- P <-- P  |  I <-- P <-- P  |  I <-- P ...
+-----------------+-----------------+--------------
]]></artwork></figure>

<t>This is a useful abstraction because GoPs can always be decoded independently.</t>

</section>
<section anchor="appendix.svc" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This layered coding means that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
      +-------------------------+------------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P ...
      +-------------------------+------------------
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.audio" title="Audio">
<t>Audio is dramatically simpler than video as it is not typically delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>The encoder spits out a continuous stream of samples (S):</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S ...
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.examples" title="Appendix B. Segment Examples">
<t>Warp offers a large degree of flexability on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of some options available.</t>

<section anchor="video" title="Video">

<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and all frames that directly or indirectly reference it (<xref target="appendix.gop"/>).
The tail of a GoP can be dropped without causing decode errors, even if the encoding is otherwise unknown, making this the safest option.</t>

<t>It is RECOMMENDED that each segment consist of a single GoP.
For example:</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

<t>Depending on the video encoding, this approach may introduce unnecessary ordering and dependencies.
A better option may be available below.</t>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy (<xref target="appendix.svc"/>).</t>

<t>When SVC is used, it is RECOMMENDED that each segment consist of a single layer and GoP.
For example:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the encoder MAY can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>For example, we could split our example B-frame structure (<xref target="appendix.b-frame"/>) into 13 segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, segments can be merged with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

</section>
<section anchor="init" title="Init">
<t>Initialization data (<xref target="appendix.init"/>) is required to initialize the decoder.
Each segment MAY start with initialization data although this adds overhead.</t>

<t>Instead, it is RECOMMENDED to create a init segment.
Each media segment can then depend on the init segment to avoid the redundant overhead.
For example:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 5
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|              init             |  init
+-------------------------------+---------
             segment 1           segment 4
]]></artwork></figure>

</section>
</section>
<section anchor="audio" title="Audio">
<t>Audio (<xref target="appendix.audio"/>) is much simpler than video so there's fewer options.</t>

<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

<t>Since video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
<section anchor="appendix.delivery-order" title="Delivery Order">
<t>The delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>The delivery order may be changed if the content changes.
For example, switching from a live stream (skippable) to an advertisement (unskippable).</t>

</section>
</section>
<section numbered="false" anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Alan Frindell</t>
  <t>Charles Krasic</t>
  <t>Cullen Jennings</t>
  <t>James Hurley</t>
  <t>Jordi Cenzano</t>
  <t>Mike English</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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
AA==

-->

</rfc>

