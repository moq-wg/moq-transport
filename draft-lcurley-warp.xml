<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Layered Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a layered live media transport protocol.
Media is split into layers based on the underlying media encoding.
Each layer is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important layers to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="layers"/> covers how media is encoded and split into layers.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t>TODO definitions</t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media layers in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The difference between the two has historically been push versus pull.
This is an over-simplification, as the real difference is the ability to fanout, which is much easier with HTTP GET.
A single protocol can cover both use-cases with adequate information on how an intermediary should forward media.</t>
  <t>A configurable latency versus quality trade-off.
The broadcaster (producer) chooses how to encode and transmit media based on the desired user experience.
Each viewer (consumer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="layers" title="Layers">
<t>Warp is based on the concept of layered coding.
A layer is a combination of a media bitstream and a set of properties.</t>

<t><list style="symbols">
  <t>The encoder determines how to split the encoded bitstream into layers (<xref target="media"/>).</t>
  <t>Each layer is transferred over a QUIC stream, which are delivered independently according to the layer properties (<xref target="properties"/>).</t>
  <t>The decoder receives each layer and skips any layers that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstream is then fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.</t>

<t>Warp works by splitting the codec bitstream into layers that can be transmitted independently.
The producer determines how to split the bistream into layers: based on the track, GoP, frame/sample, or even slice.
Depending on how the layers are produced, the consumer has the ability to decode layers out of order and skip over gaps.
See the appendix for examples based on media encoding (<xref target="appendix.examples"/>).</t>

<t>TOOD specify CMAF</t>

<t>A layer MUST contain a single track.
A layer MAY contain any number of samples which MUST be in decode order (increasing DTS).
There MAY be gaps between samples, as specified by the presentation timestamp and duration within the container.</t>

<t>The goal of layers is to produce a hierarchy.
Layers MAY depend on any number of other layers and MAY overlap with other layers.</t>

</section>
<section anchor="properties" title="Properties">
<t>Each layer has properties to go along with its contents.
These are written on the wire and inform how they layer should be transmitted at each hop.
This is primarily for the purpose of supporting intermediaries, but some of this information may also be used by the decoder.</t>

<t>All currently defined properties are optional.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
A numeric identifier for the layer.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
A numeric priority such that the smaller values take priority.
A sender SHOULD transmit layers with smallest value first, effectively starving layers with larger values during congestion.
If two layers use the same value, they SHOULD be round-robined.
Note that layers can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
A list of numeric layer IDs.
This informs the decoder that it MUST receive and process the dependency layers first.
The decoder MAY support stream processing, such that it does not need to fully receive the dependency layers first.
The layer SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">cache</spanx>.
TODO Indicates the layer should be cached for some amount of time since last access. What about fragments with an unbounded age? Should we send an <spanx style="verb">expire</spanx> message instead?</t>
  <t><spanx style="verb">expires</spanx>.
TODO Indicates the layer should be dropped after some amount of time (ex. <spanx style="verb">RESET_STREAM</spanx>). Do we need clock sync for this? How does this interact with <spanx style="verb">cache</spanx>?</t>
  <t><spanx style="verb">timestamp</spanx>.
TODO The presentation timestamp of the earliest (not always first) frame in the layer. What does an intermediary need this for?</t>
  <t><spanx style="verb">track</spanx>
TODO The track identifier to be used in conjunction with the TRACK message.</t>
</list></t>

<t>See the appendix for some example layers and properties. <xref target="appendix.examples"/></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The consumer will receive multiple layers over the network in parallel.
The decoder MUST synchronize layers using presentation timestamps within the bitstream.
The decoder might not support decoding each layer independently, so the consumer MAY need to reorder prior to passing a bitstream to the decoder.</t>

<t>Layers are NOT REQUIRED to be aligned within or between tracks.
For example, a low quality rendition may have more frequent I-frames, and thus layers, than a higher quality rendition.
A decoder MUST be prepared to skip over any gaps between layers.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.
A WebTransport session mimics the QUIC API: either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

<t>TODO define auth inside the protocol?</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message. TODO better name.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a layer, the header MUST match the layer properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<t>TODO define more error codes</t>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document varint identifier
TODO more message types</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>LAYER <xref target="layer"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in layer properties (<xref target="properties"/>).</t>

<t>TODO better name
TODO document wire format
TODO use QPACK?</t>

</section>
<section anchor="layer" title="LAYER">
<t>A <spanx style="verb">LAYER</spanx> message consists of the layer bitstream.
A <spanx style="verb">LAYER</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the layer properties (<xref target="properties"/>).</t>

<t>TODO document CMAF
TODO document wire format
TODO support multiple container formats</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

<t>TODO document wire format</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving layers from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO expand</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.examples" title="Appendix A. Layer Examples">
<t>Warp offers a large degree of flexability on how layers are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of media encoding and some options available.</t>

<section anchor="recommended" title="Recommended">
<t>Before explaining all of the options, there is a recommended approach:</t>

<t><list style="symbols">
  <t>a video layer per GoP (<xref target="appendix.gop"/>)</t>
  <t>an audio layer at roughly the same timestamp (<xref target="appendix.segments"/>)</t>
</list></t>

<t>TODO section on prioritization
* audio should be delivered before video
* for new media should be delivered before old media, or the opposite if reliability is desired</t>

</section>
<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Traditionally, these tracks could be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so they must be demuxed.</t>

<t>The simplest configuration is a single, continuous layer per track.
This allows tracks to be prioritized during congestion, although no media can be dropped.
The next section covers how to further split layers based on the type of media.</t>

</section>
<section anchor="video" title="Video">

<section anchor="encoding" title="Encoding">
<t>Video is a sequence of frames with a display timestamp.
To improve compression, frames are encoded as deltas and can reference number of frames in the past (P-frames) and/or in the future (B-frames).
A frame with no dependencies (I-frame) is effectively an image file and is a seek point.</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>Another common encoding structure is to use B-frames in a fixed pattern, which is easier for hardware encoding.
B-frames reference one or more future frames, which improves the compression ratio but increases latency.</t>

<t>This example is referenced in later sections:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  /   \ /   \     /   \ /   \     /   \
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>Note that the B-frames reference I and P frames in this example, despite the lack of an arrow.
TODO better ASCII art</t>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency still have a lot of options for references.</t>

</section>
<section anchor="decode-order" title="Decode Order">
<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its dependencies.
This is only relevant for B-frames as they must be buffered until the frame they reference has been flushed.</t>

<t>A layer MUST be in decode order.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
encode order: I B P B P I B P B P I B P ..
decode order: I P B P B I P B P B I P B ..
]]></artwork></figure>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and the frames that directly or indirectly reference it.
Each GoP can be decoded independently and thus can be transmitted independently.
It is also safe to drop the tail of the GoP (in decode order) without causing decode errors.</t>

<t>A layer MAY consist of an entire GoP.
A layer MAY consist of multiple sequential GoPs.</t>

<t>Our example GoP structure would be split into three layers.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>The concept of layers is borrowed from scalable video coding (SVC).
When SVC is enabled, the encoder produces multiple bitstreams in a hierarchy.
Dropping the top layer degrades the user experience in a configured way, such as reducing the resolution, picture quality, and/or frame rate.</t>

<t>A layer MAY consist of an entire SVC layer.</t>

<t>Our example GoP structure would be split into six layers, assuming the B frames are part of a SVC layer:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that SVC encoding is more complicated than this; our example is a simple temporal encoding scheme.</t>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the producer can split a GoP into multiple layers based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>A layer MAY consist of a single frame.</t>

<t>Our example GoP structure could be split into thirteen layers:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of layers, frames can be appended to a layer they depend on.
Layers are delivered in order so this is simpler and produces the same user experience.</t>

<t>A layer MAY consist of multiple frames within the same GoP.</t>

<t>The same GoP structure can be represented using eight layers:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of layers by combining some frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the layer, or within a dependency layer.
For example, non-reference frames can have their own layer so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six layers, although we've removed our ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that this is identical to our SVC example; we've effectively implemented our own temporal coding scheme.</t>

</section>
<section anchor="slices" title="Slices">
<t>Frames actually consist of multiple slices that reference other slices.
It's conceptually simpler to work with frames instead of slices, but splitting slices into layers may be useful.
For example, intra-refresh splits an I-frame into multiple I-slices (TODO terminology) and spread over multiple frames to smooth out the bitrate.
TODO are slices necessary?</t>

<t>A layer MAY consist of a single slice.
A layer MAY consist of multiple slices that are part of the same GoP.</t>

</section>
<section anchor="init" title="Init">
<t>For the most byte-conscious applications, initialization data can be sent over its own layer.
Multiple layers can depend on this initialization layer to avoid redundant transmissions.
For example: this is the init segment in CMAF (<spanx style="verb">moov</spanx> with no samples), which contains the SPS/PPS NALUs for h.264.</t>

<t>A layer MAY consist of no samples.</t>

<t>Our example layer per GoP would have an extra layer added:</t>

<figure><artwork><![CDATA[
     layer 2         layer 3      layer 4
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|                     init
+-----------------------------------------
                     layer 1
]]></artwork></figure>

<t>An initialization layer MUST be cached in memory until it expires.
TODO How do we do this?</t>

</section>
</section>
<section anchor="audio" title="Audio">

<section anchor="encoding-1" title="Encoding">
<t>Audio is dramatically simpler than video as it is not delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".
Frames do not depend on other frames and have a timestamp for synchronization.</t>

<t>In the below diagrams, each audio frame is denoted with an S.
The encoder spits out a continuous stream of samples:</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S
]]></artwork></figure>

</section>
<section anchor="simple" title="Simple">
<t>The simplest configuration is to use a single layer for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<t>A layer SHOULD consist of multiple audio frames.</t>

<figure><artwork><![CDATA[
          layer 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

</section>
<section anchor="periodic-refresh" title="Periodic Refresh">
<t>An improvement is to periodically split audio samples into separate layers.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio layers is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a layer for each audio frame because of this overhead.</t>

</section>
<section anchor="appendix.segments" title="Segments">
<t>Video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio layer at each video I-frame.</t>

<figure><artwork><![CDATA[
     layer 1         layer 3      layer 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
     layer 2         layer 4      layer 6
]]></artwork></figure>

<t>This is effectively how HLS/DASH segments work, with the exception that the most recent layers are still pending.</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAI/OUWMAA+1963IbyZHufzxFreaHxTWAoTQXezh7YkyRlMQYSuIhKU84
ztmwCo0C0VajG+7qJglLcuxD7APss5xHOU9y8svMqq5ugJTGJzb2z8oeCJeu
W2ZW5peXKk0mk1GTN4U7MI9+sfXaTMyZ3bjazc1ZfuPMKzfPrbmqbenXVd08
GtnZrHY3B+aXw4vz0bzKSruitvPaLppJkbV14TaTW+poUtjG+WY0p78OzIfj
w6uTT6OMPlxX9ebA5OWiGo3ydX1gmrr1zdP9/R/2n45s7eyBeeFKV9tidFvV
76/rql0fmNNy7taOXsrGXLazVe59XpWj925DD83xe+Pq0jWTY8xkNPKNLed/
tkVV0ugb50d+Zevmz39tK5rVgSmr0To/MP+rqbKx8bSw2i08vdus5A0tbGXX
67y8/tfRyLbNsqoPRsZM6D9Dc6cezqbmiFfLXwkVztr3Lv22qq9tmf/NNjTV
A3N1mzfZkn9wK5sXB+Z9fudApvkfrvHFNKtWo/4oP0/NeXudl8kgP+d1XhTJ
1/1RXrnGpmPk7/P6Dyv6ckfvl1Pzmshk37dEnGSIy3Zp/fCn/jBHuc+qdBxf
yuN/yPCLDDYqq3pFDW4ciPc/354eHZiL50c/7O/v6+fJxcnRmz+eXPwp/PCU
fvjFzaLAEWcnx9PcNYvJrZs1+HqybJr1N1jK6eWbZ6+ePz/geQQpPiXJ4lGr
0jQuW5ZVUV1vzP/9t383R9WcOGqqhbHtPK8mN7lvbWGq2V9c1nh+5JykxDx5
eoC+zTPrww54nhfOPOeOH/FwItdP9598N3nylCQ5jCprPXp1+GXTmkzMq7Zo
8hWPQiJX5Jk8JI+bx6/OT15MDvfwpEzuB6J+tVrRI/c3wvh7+GS8u17RpqH9
zE/3J/90f7L/DX3z2t1euLJiJnz/3e/BhGfPLoT2ma3nt64oJnmW1dcT2v6T
rCqvaW/TgHjb1FUxIcaNRhOao5154lJGW/BqmXtspBbjm7lb5KXzplk6k1W1
MzO3tDc5zRCzhOoZG2sK1T0FdI8srwmiYNZ1Rfu1KqYj4Ql172npDQlzU0lT
b2bEs7kBkWmglhRGXWzAdOnMlRnLwHR0YrOltEE/PMgqb0CnvFM1xcZUN/SE
ZWE1tDJnV9NR8sEbUlk0M1pI3uR/c3NaRVFUtxiycN6bfIW5W6KATpCmOnPU
2tY3mGhNurNar+ntvK3RqiPuVCi6yufzwhF5v/oKaq6u5m2Gn0esr2ny9mFy
ESVIJNomL2h+wgBeAGlLKNjuuQ8f8P2nTzTuhw+rimSZherTJ5rTDU+dms5s
xjq5nBva8KbmR2zB/CTKMSen1F5W27VdVrc6Q5oxs8FJD1ssROu/tnnWb8tT
pqYt2EvP8joXxBvuFG1WRG5LpBuOKd8yn8K4Kh63ee2mQtgrV4OXNJ9jCGqO
VXnIsDNkYwyMjDePXr29vHo0lr/N6zf8/uKEpnZxcoz3ly8Pz87im5E+cfny
zduz4+5d1/LozatXJ6+PpTF9a3pfjR69OvwT/YJZPXpzfnX65vXh2SMiFU0+
3VpYmUhVDiu4rh3E2PrR3Pmszmcs0+bZ0fn/+Y8n3xKX/4l2+dMnT34gQsmH
3z/53bf04XbpShmtKkny5SPRaTMiFeNsjV5IuE1m13ljCzKTZCU8Ebk0SyeU
FMVEjYVNTNSd8+2mNnO0Xajt1ZvjN6IlAvFHX5lXUQqZS2ekt8psMzqliZi1
qxekt8GbgrbdLfRKW9A+ctgOdbopSP7Bb0/WDRJLhGogS2veS24+ZT7Tlp80
1YT+MoWMw5bCzOrKzjPrMRL6JzovyHDPO0r5li0ImBAUDP+oWoWhCqZlNyTc
b2EImrakIYrNOOxCElZL072xdW5ntJuaJe2x6+W6bcbQLmSEcxpo3jKneyri
kJTWat1gTPopLF7WXdj6mj6QAlAexP7D5p/lDRMks8Qxb/7aupbVIytv/UQ/
lqbKCNzRqja34LUwlRSfbZZEkObWOflCdljNy587fj8dkd007s6u1rCEeCox
WSxh5s0lobDsvWtgBG7zRW5o+SQ+xNacJk7sLskin4+hL68FHRI5erMBrfOG
CHK6IHiHRteGpa50oPKtWdTEfk8dkgjPeA5Q8qJMhP3Cb9JurL6xescL4SaN
JXBXgPI1mti6hnwpaV1eE5scrZjUTVXT1sjLjOyDZzsg0jQdvSEK/qWascGp
SK+X+YpUMo+OQYmUNIEmUN7JXlwQvGLmkhYnhPo+X3MDmR32qFlXJGHEVGyi
ZQuj6CCdJK/LnIycVWGIeh7snJOOIIllFe7IXpRMh8Bw/Fqvor2OC/jFceOO
A1lhaezFhtib+6azs2EsL4qdZM0o9s/d/TZ6aJEORqN/NldH5xNpMOz6sbub
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
Edz8fzxakA12jz5JUdfo/wHQ0RbTQnMAAA==

-->

</rfc>

