<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Layered Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a layered live media transport protocol.
Media is split into layers based on the underlying media encoding.
Each layer is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important layers to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="layers"/> covers how media is encoded and split into layers.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media layers in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="layers" title="Layers">
<t>Warp is based on the concept of layered coding.
A layer is a combination of a media bitstream and a set of properties.</t>

<t><list style="symbols">
  <t>The encoder determines how to split the encoded bitstream into layers (<xref target="media"/>).</t>
  <t>Each layer is transferred over a QUIC stream, which are delivered independently according to the layer properties (<xref target="properties"/>).</t>
  <t>The decoder receives each layer and skips any layers that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstream is then fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.</t>

<t>Warp works by splitting the codec bitstream into layers that can be transmitted independently.
The producer determines how to split the bistream into layers: based on the track, GoP, frame/sample, or even slice.
Depending on how the layers are produced, the consumer has the ability to decode layers out of order and skip over gaps.
See the appendix for examples based on media encoding (<xref target="appendix.examples"/>).</t>

<t>TOOD specify CMAF</t>

<t>A layer MUST contain a single track.
A layer MAY contain any number of samples which MUST be in decode order (increasing DTS).
There MAY be gaps between samples, as specified by the presentation timestamp and duration within the container.</t>

<t>The goal of layers is to produce a hierarchy.
Layers MAY depend on any number of other layers and MAY overlap with other layers.</t>

</section>
<section anchor="properties" title="Properties">
<t>Each layer has properties to go along with its contents.
These are written on the wire and inform how they layer should be transmitted at each hop.
This is primarily for the purpose of supporting intermediaries, but some of this information may also be used by the decoder.</t>

<t>All currently defined properties are optional.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
A numeric identifier for the layer.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
A numeric priority such that the smaller values take priority.
A sender SHOULD transmit layers with smallest value first, effectively starving layers with larger values during congestion.
If two layers use the same value, they SHOULD be round-robined.
Note that layers can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
A list of numeric layer IDs.
This informs the decoder that it MUST receive and process the dependency layers first.
The decoder MAY support stream processing, such that it does not need to fully receive the dependency layers first.
The layer SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">cache</spanx>.
TODO Indicates the layer should be cached for some amount of time since last access. What about fragments with an unbounded age? Should we send an <spanx style="verb">expire</spanx> message instead?</t>
  <t><spanx style="verb">expires</spanx>.
TODO Indicates the layer should be dropped after some amount of time (ex. <spanx style="verb">RESET_STREAM</spanx>). Do we need clock sync for this? How does this interact with <spanx style="verb">cache</spanx>?</t>
  <t><spanx style="verb">timestamp</spanx>.
TODO The presentation timestamp of the earliest (not always first) frame in the layer. What does an intermediary need this for?</t>
  <t><spanx style="verb">track</spanx>
TODO The track identifier to be used in conjunction with the TRACK message.</t>
</list></t>

<t>See the appendix for some example layers and properties. <xref target="appendix.examples"/></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The consumer will receive multiple layers over the network in parallel.
The decoder MUST synchronize layers using presentation timestamps within the bitstream.
The decoder might not support decoding each layer independently, so the consumer MAY need to reorder prior to passing a bitstream to the decoder.</t>

<t>Layers are NOT REQUIRED to be aligned within or between tracks.
For example, a low quality rendition may have more frequent I-frames, and thus layers, than a higher quality rendition.
A decoder MUST be prepared to skip over any gaps between layers.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

<t>TODO define auth inside the protocol?</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message. TODO better name.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a layer, the header MUST match the layer properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<t>TODO define more error codes</t>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document varint identifier
TODO more message types</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>LAYER <xref target="layer"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in layer properties (<xref target="properties"/>).</t>

<t>TODO better name
TODO document wire format
TODO use QPACK?</t>

</section>
<section anchor="layer" title="LAYER">
<t>A <spanx style="verb">LAYER</spanx> message consists of the layer bitstream.
A <spanx style="verb">LAYER</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the layer properties (<xref target="properties"/>).</t>

<t>TODO document CMAF
TODO document wire format
TODO support multiple container formats</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

<t>TODO document wire format</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving layers from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO expand</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.examples" title="Appendix A. Layer Examples">
<t>Warp offers a large degree of flexability on how layers are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of media encoding and some options available.</t>

<section anchor="recommended" title="Recommended">
<t>Before explaining all of the options, there is a recommended approach:</t>

<t><list style="symbols">
  <t>a video layer per GoP (<xref target="appendix.gop"/>)</t>
  <t>an audio layer at roughly the same timestamp (<xref target="appendix.segments"/>)</t>
</list></t>

<t>TODO section on prioritization
* audio should be delivered before video
* for new media should be delivered before old media, or the opposite if reliability is desired</t>

</section>
<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Traditionally, these tracks could be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so they must be demuxed.</t>

<t>The simplest configuration is a single, continuous layer per track.
This allows tracks to be prioritized during congestion, although no media can be dropped.
The next section covers how to further split layers based on the type of media.</t>

</section>
<section anchor="video" title="Video">

<section anchor="encoding" title="Encoding">
<t>Video is a sequence of frames with a display timestamp.
To improve compression, frames are encoded as deltas and can reference number of frames in the past (P-frames) and/or in the future (B-frames).
A frame with no dependencies (I-frame) is effectively an image file and is a seek point.</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>Another common encoding structure is to use B-frames in a fixed pattern, which is easier for hardware encoding.
B-frames reference one or more future frames, which improves the compression ratio but increases latency.</t>

<t>This example is referenced in later sections:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  /   \ /   \     /   \ /   \     /   \
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>Note that the B-frames reference I and P frames in this example, despite the lack of an arrow.
TODO better ASCII art</t>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency still have a lot of options for references.</t>

</section>
<section anchor="decode-order" title="Decode Order">
<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its dependencies.
This is only relevant for B-frames as they must be buffered until the frame they reference has been flushed.</t>

<t>A layer MUST be in decode order.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
encode order: I B P B P I B P B P I B P ..
decode order: I P B P B I P B P B I P B ..
]]></artwork></figure>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and the frames that directly or indirectly reference it.
Each GoP can be decoded independently and thus can be transmitted independently.
It is also safe to drop the tail of the GoP (in decode order) without causing decode errors.</t>

<t>A layer MAY consist of an entire GoP.
A layer MAY consist of multiple sequential GoPs.</t>

<t>Our example GoP structure would be split into three layers.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>The concept of layers is borrowed from scalable video coding (SVC).
When SVC is enabled, the encoder produces multiple bitstreams in a hierarchy.
Dropping the top layer degrades the user experience in a configured way, such as reducing the resolution, picture quality, and/or frame rate.</t>

<t>A layer MAY consist of an entire SVC layer.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
                layer 3              layer 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

                layer 2              layer 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

                layer 1              layer 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the producer can split a GoP into multiple layers based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>A layer MAY consist of a single frame.</t>

<t>Our example GoP structure could be split into thirteen layers:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of layers, frames can be appended to a layer they depend on.
Layers are delivered in order so this is simpler and produces the same user experience.</t>

<t>A layer MAY consist of multiple frames within the same GoP.</t>

<t>The same GoP structure can be represented using eight layers:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of layers by combining some frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the layer, or within a dependency layer.
For example, non-reference frames can have their own layer so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six layers, although we've removed our ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that this is identical to our SVC example; we've effectively implemented our own temporal coding scheme.</t>

</section>
<section anchor="slices" title="Slices">
<t>Frames actually consist of multiple slices that reference other slices.
It's conceptually simpler to work with frames instead of slices, but splitting slices into layers may be useful.
For example, intra-refresh splits an I-frame into multiple I-slices (TODO terminology) and spread over multiple frames to smooth out the bitrate.
TODO are slices necessary?</t>

<t>A layer MAY consist of a single slice.
A layer MAY consist of multiple slices that are part of the same GoP.</t>

</section>
<section anchor="init" title="Init">
<t>For the most byte-conscious applications, initialization data can be sent over its own layer.
Multiple layers can depend on this initialization layer to avoid redundant transmissions.
For example: this is the init segment in CMAF (<spanx style="verb">moov</spanx> with no samples), which contains the SPS/PPS NALUs for h.264.</t>

<t>A layer MAY consist of no samples.</t>

<t>Our example layer per GoP would have an extra layer added:</t>

<figure><artwork><![CDATA[
     layer 2         layer 3      layer 4
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|                     init
+-----------------------------------------
                     layer 1
]]></artwork></figure>

<t>An initialization layer MUST be cached in memory until it expires.
TODO How do we do this?</t>

</section>
</section>
<section anchor="audio" title="Audio">

<section anchor="encoding-1" title="Encoding">
<t>Audio is dramatically simpler than video as it is not typically not delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>In the below diagrams, each audio frame is denoted with an S.
The encoder spits out a continuous stream of samples:</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S
]]></artwork></figure>

</section>
<section anchor="simple" title="Simple">
<t>The simplest configuration is to use a single layer for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<t>A layer SHOULD consist of multiple audio frames.</t>

<figure><artwork><![CDATA[
          layer 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

</section>
<section anchor="periodic-refresh" title="Periodic Refresh">
<t>An improvement is to periodically split audio samples into separate layers.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio layers is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a layer for each audio frame because of this overhead.</t>

</section>
<section anchor="appendix.segments" title="Segments">
<t>Video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio layer at each video I-frame.</t>

<figure><artwork><![CDATA[
     layer 1         layer 3      layer 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
     layer 2         layer 4      layer 6
]]></artwork></figure>

<t>This is effectively how HLS/DASH segments work, with the exception that the most recent layers are still pending.</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </back>

<!-- ##markdown-source:
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
H7DlxIi96ADvTgNFVJFzN4Mx2CnCsW3ghcLOqYIwtAziryK1GBVoZgg3jxYu
apDMmtjJJVkoIg1wBJ6kvdfOZBXEkIwVC9OJs+wwPxxPIZnS8MtGpWpXIIXM
+7sCjeskZ3vc4xSSynpDrLnCihx/2BnBacSJ/GOIi2bNH2h25PQWpP9owyfA
9EmuoVG0L+cNY8JFWcL3oskMGUjdYVNocazZybL8AZEQGGJxLZM1Fkl4rUK4
CEqjzLNZoiuIzNyQsXl1SyCK9Pxi2WBTiWeSwpK3TJuX8coJHSWxEA5VndGe
PmPHLm3rplxBlsMKBd5zmFQ0qAcoUD/XDud0h29gKHpzmJHKJg+f7GxnHmdn
I1an/OtpKWIL3SrogVyavd84QY+nr1kl9vURNDa58CR6Oc/KYVlwNvyqSLhy
+wNx369txvzDCkDxFubJ+qC9DwCGWIZlbk5CCjWrRjno7cIK56/IK4dnTlRb
JwyIyIvwmDuC1/c0jYZUg86C9UL9uLSnGqBkMMb+ZVO1KzxKNmBE+0Yempmo
2wkSsNk78szFaqqQnXJK32+dyrlV6xLIl9oOLoMFzkSfqYpigU+IuUVBixub
mKPjt+YGKhmhOTxSVsTvzojQG2+NGstKIhdL1zaDYgCejoDgzAPMLZH/kWim
PkIHmQi5WCV6+jirMxNe4LkwkkgY/CG6IoCiN2kmFbGOC0ESXTlsNc8WLXOT
N2DQOy1wVyK0QUhpVM7njrjiB5qnkayRxVyWJWano8qSY+TfKNk6gAcaF+EG
Wl0lDJVhuzTg7YhrnorUdEcB/hQVRH3DUG73T4DhgRFEoNQ9BZa7S1jK4ke8
rbkFM80rkm2SmHwEx5rbIxK34aEJWKtkD1X1k7qf+YdGHFzn+FQh8Q/3MGQK
ERwva95pNRwpUL0wdvH0aMN1N+ytgmJW1nPhbJp4wDxd7cJeNFZJEONW1kF+
wR8a86QmibNPiBqM89hwkHRa3x265tbe7GOtJflbCt2JVGQehxr9bmqbz9W1
ZF1AvYivGZthBOLEapELi8ggKE+0YOBAvu08IbtuEWmpy5WNEPAO7LvXXYmx
GdMaS+R4+n2at7WAR46YcoSto04g9QQgaGmioUEAEj5H057K4GG2fQrR+YwJ
IhGFa7yWJCE9eU8bSFiOFo5/SdHQ78lP7+i3bVK1XG0KDwrK8c319UMANosB
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
VLkN/h91jLp303oAAA==

-->

</rfc>

