<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol.
Media is split into segments based on the underlying media encoding.
Each segment is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="segments"/> covers how media is encoded and split into segments.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media segments in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over the network somewhat independently.
A segment is a fragmented MP4 {ISOBMFF} containing a single track and any number of frames/samples.
Each segment has a set of properties, written separately on the wire, that dictates how it should be delivered.</t>

<t><list style="symbols">
  <t>The encoder determines how to split the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>Each segment is transferred over a QUIC stream, which are delivered independently according to the segment properties (<xref target="properties"/>).</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstream is then fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.</t>

<t>Warp works by splitting the codec bitstream into segments that can be transmitted independently.
The producer determines how to split the bistream into segments: based on the track, GoP, frame/sample, or even slice.
Depending on how the segments are produced, the consumer has the ability to decode segments out of order and skip over gaps.
See the appendix for examples based on media encoding (<xref target="appendix.examples"/>).</t>

<t>TOOD specify CMAF</t>

<t>A segment MUST contain a single track.
A segment MAY contain any number of samples which MUST be in decode order (increasing DTS).
There MAY be gaps between samples within a segment.</t>

<t>Segments MAY depend on any number of other segments and MAY overlap with other segments.
This allows the creation of a hierarchy for more sophisticated encoding and delivery (ex. SVC).</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>Warp responds to congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>The encoder determines the value assigned to each segment based the media encoding and desired user experience.
Multiple segments MAY use the same value, in which case they SHOULD be delivered via round-robin.
See the appendix for examples (<xref target="appendix.examples"/>).</t>

<t>A sender SHOULD attempt to deliver segments based on this delivery order.
This effectively involves creating a priority queue in ascending order, allocating any avaiable bandwidth to the next pending segment.
Since each segment is sent over a dedicated QUIC stream, the next QUIC packet SHOULD contain a STREAM frame for the next pending segment, repeated until the congestion window is hit.
The sender MAY ignore the delivery order for retransmits and MUST ignore it when flow control limits are reached.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:
* Newly encoded segments MAY have a smaller delivery order than outstanding segments.
* Packet loss or flow control MAY delay the delivery of individual streams.
* The sender might not support QUIC stream prioritization.</t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the latency.</t>

<t>A proxy MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.
This is NOT RECOMMENDED unless the proxy knows additional information about the media.
For example, a proxy could use the PTS as the delivery order to enable head-of-line blocking for content that should not be skipped, like an advertisement.</t>

</section>
<section anchor="properties" title="Properties">
<t>Each segment has properties to go along with its contents.
These are written on the wire and SHOULD be parsed by any Warp intermediaries.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An optional, numeric identifier for the segment.
This value is only used for association and identification; a receiver MUST NOT assume it is monotically increasing.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
An optional, numeric value indicating the delivery order (<xref target="delivery-order"/>).
A sender SHOULD transmit segments with smallest value first, as bandwidth permits.
If two segments use the same value, they SHOULD be round-robined.
Note that segments can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An optional list of dependencies segments by ID.
The decoder SHOULD process the specified dependencies first.
The decoder MAY support stream processing via the decode timestamp (DTS), such that it does not need to fully receive the dependency segments first.
The segment SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">track</spanx>.
A numeric identifier of the track.
This MAY be different than the track ID within the container.</t>
</list></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel.
The decoder MUST synchronize segments using presentation timestamps within the bitstream.
The decoder SHOULD use a buffer to reorder frames/samples from separate segments into decode order.</t>

<t>Segments are NOT REQUIRED to be aligned.
A decoder MUST be prepared to skip over any gaps between segments.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a segment, the header MUST match the segment properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>SEGMENT <xref target="segment"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in segment properties (<xref target="properties"/>).</t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of the segment bitstream.
A <spanx style="verb">SEGMENT</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the segment properties (<xref target="properties"/>).</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving segments from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.examples" title="Appendix A. Segment Examples">
<t>Warp offers a large degree of flexability on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of media encoding and some options available.</t>

<section anchor="recommended" title="Recommended">
<t>Before explaining all of the options, there is a recommended approach:</t>

<t><list style="symbols">
  <t>a video segment per GoP (<xref target="appendix.gop"/>)</t>
  <t>an audio segment at roughly the same timestamp (<xref target="appendix.gos"/>)</t>
</list></t>

<t>This matches the segment encoding of HLS/DASH and the same files may be used, provided there's only one track.</t>

<t>The recommended delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

</section>
<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Traditionally, these tracks could be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so they must be demuxed.</t>

</section>
<section anchor="video" title="Video">

<section anchor="encoding" title="Encoding">
<t>Video is a sequence of frames with a display timestamp.
To improve compression, frames are encoded as deltas and can reference number of frames in the past (P-frames) and/or in the future (B-frames).
A frame with no dependencies (I-frame) is effectively an image file and is a seek point.</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>Another common encoding structure is to use B-frames in a fixed pattern, which is easier for hardware encoding.
B-frames reference one or more future frames, which improves the compression ratio but increases latency.</t>

<t>This example is referenced in later sections:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency still have a lot of options for references.</t>

</section>
<section anchor="decode-order" title="Decode Order">
<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its dependencies.
This is only relevant for B-frames as they must be buffered until the frame they reference has been flushed.</t>

<t>A segment MUST be in decode order.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
encode order: I B P B P I B P B P I B P ..
decode order: I P B P B I P B P B I P B ..
]]></artwork></figure>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and the frames that directly or indirectly reference it.
Each GoP can be decoded independently and thus can be transmitted independently.
It is also safe to drop the tail of the GoP (in decode order) without causing decode errors.</t>

<t>A segment MAY consist of an entire GoP.
A segment MAY consist of multiple sequential GoPs.</t>

<t>Our example GoP structure would be split into three segments.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This is layered coding, such that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>A segment MAY consist of an entire SVC layer.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the producer can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>A segment MAY consist of a single frame.</t>

<t>Our example GoP structure could be split into thirteen segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, frames can be combined with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>A segment MAY consist of multiple frames within the same GoP.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

<t>Note that this is identical to our SVC example; we've effectively implemented our own temporal coding scheme.</t>

</section>
<section anchor="init" title="Init">
<t>For the most byte-conscious applications, initialization data can be sent as its own segment.
Multiple segments can depend on this initialization segment to avoid redundant transmissions.</t>

<t>A segment MAY consist of no samples.</t>

<t>Our example segment per GoP would have an extra segment added:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 4
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|                     init
+-----------------------------------------
                    segment 1
]]></artwork></figure>

<t>An initialization segment MUST be cached in memory until it expires.
TODO How do we do this?</t>

</section>
</section>
<section anchor="audio" title="Audio">

<section anchor="encoding-1" title="Encoding">
<t>Audio is dramatically simpler than video as it is not typically not delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>In the below diagrams, each audio frame is denoted with an S.
The encoder spits out a continuous stream of samples:</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S
]]></artwork></figure>

</section>
<section anchor="simple" title="Simple">
<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<t>A segment SHOULD consist of multiple audio frames.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

</section>
<section anchor="periodic-refresh" title="Periodic Refresh">
<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

</section>
<section anchor="appendix.gos" title="Group of Samples">
<t>Video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAEMeVmMAA91963IbR5bmfzxFrvyjqW0ApiTbbdMzMU2RtMxoUeSSVDs6
djdGiUICqGGhCq6sIoWW1LEPsQ+wz7KPsk+y55qZVShQsjcmJmLZbYoAKm8n
z+U7l0xMJpNRkzeFOzJPfrH1xkzMjVuuXdm4uXmd3ztz4ea5Nbe1Lf2mqpsn
Izub1e7+yPxyfH01mldZadfQel7bRTMpsrYu3HbyAF1NCts434zm8M+R+XB6
fHv2aZTBi2VVb49MXi6q0Sjf1EemqVvfPD88/OHw+cjWzh6ZV650tS1GD1V9
t6yrdnNkzsu52zj4VTbmpp2tc+/zqhzduS08NMfPG1eXrpmc4kxGI9/Ycv6v
tqhKGH3r/Mivbd38669tBbM6MmU12uRH5r82VTY2HhZWu4WHv7Zr/gMWtrab
TV4u//toZNtmVdVHI2Mm8J+BuUMPr6fmhFZLbzEVXrd3Ln23qpe2zP9uG5jq
kbl9yJtsRR+4tc2LI3OXv3dIpvmfl/jGNKvWo+4of5maq3aZl8kgf8nrvCiS
t7ujXLjGpmPkd3n95zW8OdD7zdS8ATLZuxaIkwxx066s73/UHeYk91mVjuNL
fvzPGX7Cg43Kql5Dg3uHxPsvb89Pjsz1Tyc/HB4eyuvJ9dnJ5V/Prv+mHzyH
D35xs8BwsLOT02numsXkwc0afHuyaprNC1zK+c3ly4uffjqieSgfnwNn0ahV
aRqXrcqqqJZb83/+x/80J9UcdtRUC2PbeV5N7nPf2sJUs39zWePpkSvgEvPs
+RH2bV5arxLwU1448xN1/ISGY75+fvjs28mz58DJOiqv9eTi+MumNZmYi7Zo
8jWNAixX5Bk/xI+bg4urs1eT46f4JE/uB6B+tV7DI/sb4fhP8ZXxQZ7p6e7k
nx9ODl/AO2/cw7UrK9qE7779Hjfh5ctrpn1m6/mDK4pJnmX1cgLiP8mqcgmy
DQPin01dFRPYuNFoAnO0Mw+7lIEI3q5yj4LU4vhm7hZ56bxpVs5kVe3MzK3s
fQ4zxFmi8hkbm8y2QO3DC2yUGcymrkBiq2I64l2BATwsvgF2bipt7M0M9m1u
kNAwWAtKoy62uPHcnSsz4oPp6MxmK22FfdFA67zB8fOocIqtqe5dDdNDljWw
PmfX01HywhtQXDA7WE7e5H93c1hLUVQPOGjhvDf5GudvYZgwSZjwzEF7W9/j
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
jP4v8jk358h+AAA=

-->

</rfc>

