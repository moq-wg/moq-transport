<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-01" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol.
Warp maps live media to QUIC streams based on the underlying media encoding.
Media is prioritized to reduce latency when encountering congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="overview" title="Overview">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="connection"/> covers how QUIC is used to transfer media. QUIC streams are created for each segment and prioritized such that the most important media is delivered during congestion.</t>

<t><xref target="segments"/> covers how media is packaged into fragmented MP4 containers. Initialization segments contain track metadata while media segments contain audio and/or video samples.</t>

<t><xref target="messages"/> covers how control messages are encoded. These are used sent alongside segments to carry necessary metadata and control playback.</t>

<t><xref target="configuration"/> covers how to build an optimal live media stack. The application can configure Warp based on the desired user experience.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames.</t>
  <t hangText="Group of pictures (GOP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Segment:">
  A sequence of video frames and/or audio samples serialized into a container.</t>
  <t hangText="Media player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Media encoder:">
  A component responsible for creating a compressed media stream.</t>
  <t hangText="Media producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Media consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Middleware:">
  A media consumer that forwards streams to one or more downstream media consumers.</t>
</list></t>

</section>
</section>
<section anchor="connection" title="Connection">
<t>Warp uses the QUIC stream API to transfer media.</t>

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport over HTTP/3 <xref target="WebTransport"/>. This involves establishing a HTTP/3 connection, issuing a CONNECT request to establish the session, and exposing the underlying QUIC stream API while the session is active.</t>

<t>The application is responsible for authentication based on the CONNECT request.</t>

<t>The application is responsible for determining if an endpoint is a media producer, consumer, or both.</t>

</section>
<section anchor="streams" title="Streams">
<t>Endpoints communicate over unidirectional QUIC streams. The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>Both endpoints can create a new stream at any time. Each stream consists of byte data with an eventual final size. A stream is reliably delivered in order unless canceled early with an error code.</t>

<t>The delivery of each stream is independent. The sender MAY prioritize their delivery (<xref target="prioritization"/>); intentionally starving streams in favor of more important streams.</t>

<section anchor="contents" title="Contents">
<t>Each stream consists of MP4 top-level boxes <xref target="ISOBMFF"/> concatenated together.</t>

<t><list style="symbols">
  <t>Segments (<xref target="segments"/>) contain media samples and additional metadata. These are <spanx style="verb">ftyp</spanx>, <spanx style="verb">moov</spanx>, <spanx style="verb">styp</spanx>, <spanx style="verb">moof</spanx>, and <spanx style="verb">mdat</spanx> boxes.</t>
  <t>Messages (<xref target="messages"/>) control playback or carry metadata about segments. These are <spanx style="verb">warp</spanx> boxes.</t>
</list></t>

<t>Each <spanx style="verb">ftyp</spanx> box MUST be preceded by a <spanx style="verb">warp</spanx> box indicating that it is an initialization segment (<xref target="message-init"/>). Each <spanx style="verb">styp</spanx> box MUST be preceded by a <spanx style="verb">warp</spanx> box indicating that it is a media segment (<xref target="message-segment"/>).</t>

<t>A stream MUST start with a message and MAY contain multiple messages. A stream MUST NOT contain multiple segments.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes precedence to deliver the most important content during congestion.</t>

<t>The media producer assigns a numeric precedence to each stream. This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in descending order. QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.</t>

<t>The media producer MUST support sending prioritized streams using precedence. The media producer MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

<t>See <xref target="configuration-prioritization"/> for suggestions on how to prioritize streams based on the contents.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>During congestion, prioritization intentionally cause stream starvation for the lowest priority streams. Some form of starvation will last until the network fully recovers, which may be indefinite.</t>

<t>The media consumer SHOULD cancel a stream (via a QUIC <spanx style="verb">STOP_SENDING</spanx> frame) with application error code 0 when the segment is no longer desired. This can happen when the consumer decides to skip the remainder of a segment after some duration has elapsed. The media producer MUST NOT treat this as a fatal error.</t>

<t>The media producer SHOULD cancel the lowest priority stream (via QUIC <spanx style="verb">RESET_STREAM</spanx> frame) with application error code 0 when nearing resource limits. This can happen after sustained starvation and indicates that the consumer must skip over the remainer of a segment. The media consumer MUST NOT treat this as a fatal error.</t>

<t>Both of these actions will effectively drop the tail of the segment. The segment fragment size SHOULD be small to reduce data loss, ideally one fragment per frame.</t>

</section>
</section>
<section anchor="middleware" title="Middleware">
<t>Media may go through multiple hops and processing steps on the path from the broadcaster to player. The full effectiveness of warp as an end-to-end protocol depends on middleware support.</t>

<t><list style="symbols">
  <t>Middleware SHOULD maintain stream idependence to avoid introducing head-of-line blocking.</t>
  <t>Middleware SHOULD maintain stream prioritization when traversing networks susceptible to congestion.</t>
  <t>Middleware MUST forward the <spanx style="verb">priority</spanx> message (<xref target="message-priority"/>) to downstream servers.</t>
</list></t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the end of the media stream. Either endpoint MAY use any other error code to indicate a fatal error.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>The live stream is split into segments before being transferred over the network. Segments are fragmented MP4 files as defined by <xref target="ISOBMFF"/>.</t>

<t>There are two types of segments: initialization and media.</t>

<section anchor="initialization" title="Initialization">
<t>Initialization segments contain track metadata but no sample data.</t>

<t>Initialization segments MUST consist of a File Type Box (<spanx style="verb">ftyp</spanx>) followed by a Movie Box (<spanx style="verb">moov</spanx>). This Movie Box consists of Movie Header Boxes (<spanx style="verb">mvhd</spanx>), Track Header Boxes (<spanx style="verb">tkhd</spanx>), Track Boxes (<spanx style="verb">trak</spanx>), followed by a final Movie Extends Box (<spanx style="verb">mvex</spanx>). These boxes MUST NOT contain any samples and MUST have a duration of zero.</t>

<t>Note that a Common Media Application Format Header <xref target="CMAF"/> meets all these requirements.</t>

</section>
<section anchor="media" title="Media">
<t>Media segments contain media samples for a single track.</t>

<t>Media segments MUST consist of a Segment Type Box (<spanx style="verb">styp</spanx>) followed by at least one media fragment. Each media fragment consists of a Movie Fragment Box (<spanx style="verb">moof</spanx>) followed by a Media Data Box (<spanx style="verb">mdat</spanx>). The Media Fragment Box MUST contain a Movie Fragment Header Box (<spanx style="verb">mfhd</spanx>) and Track Box (<spanx style="verb">trak</spanx>) with a Track ID (<spanx style="verb">track_ID</spanx>) matching a Track Box in the initialization segment.</t>

<t>Note that a Common Media Application Format Segment <xref target="CMAF"/> meets all these requirements.</t>

<section anchor="segmentation" title="Segmentation">
<t>Media is broken into segments at configurable boundaries. Each media segment MUST start with an I-frame so it can be decoded independently of other media segments. Each media segment SHOULD contain a single group of pictures (GOP).</t>

</section>
<section anchor="fragmentation" title="Fragmentation">
<t>Media segments are further broken into media fragments at configurable boundaries. See <xref target="configuration-fragmentation"/> for advice on when to fragment.</t>

</section>
</section>
</section>
<section anchor="messages" title="Messages">
<t>Warp endpoints communicate via messages contained in a custom top-level <xref target="ISOBMFF"/> Box.</t>

<t>This Warp Box (<spanx style="verb">warp</spanx>) contains a single JSON object. Each key defines the message type and the value the contents. Unknown messages MUST be ignored.</t>

<t>Multiple messages with different types MAY be encoded in the same JSON object. Messages SHOULD be sent in separate boxes on the same stream when ordering is important.</t>

<section anchor="message-init" title="init">
<t>The <spanx style="verb">init</spanx> message indicates that the remainder of the stream contains an initialization segment.</t>

<figure><artwork><![CDATA[
{
  init: {
    id: int
  }
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText="id:">
  Incremented by 1 for each unique initialization segment.</t>
</list></t>

</section>
<section anchor="message-segment" title="media">
<t>The <spanx style="verb">segment</spanx> message contains metadata about the next media segment in the stream.</t>

<figure><artwork><![CDATA[
{
  segment: {
    init: int,
    timestamp: int,
    timescale: int, (optional)
  }
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText="init:">
  The id of the cooresponding initialization segment. A decoder MUST block until the cooresponding initialization segment has been fully processed.</t>
  <t hangText="timestamp:">
  The presentation timestamp in <spanx style="verb">timescale</spanx> units for the first frame/sample in the next segment. This timestamp takes precedence over the timestamp in media container to support stream stitching.</t>
  <t hangText="timescale (optional):">
  The number of units in second. This defaults to <spanx style="verb">1000</spanx> to signify milliseconds.</t>
</list></t>

</section>
<section anchor="message-priority" title="priority">
<t>The <spanx style="verb">priority</spanx> message informs middleware about the intended priority of the current stream. Middleware MUST foward this message but it is OPTIONAL to obey it.</t>

<figure><artwork><![CDATA[
{
  priority: {
    precedence: int,
  }
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText="precedence:">
  An integer value, indicating that any available bandwidth SHOULD be allocated to streams in descending order.</t>
</list></t>

</section>
<section anchor="extensions" title="Extensions">
<t>Custom messages MUST start with <spanx style="verb">x-</spanx>. Unicode LATIN SMALL LETTER X (U+0078) followed by HYPHEN-MINUS (U+002D).</t>

<t>Custom messages could control playback. For example: <spanx style="verb">x-pause</spanx> could halt the transfer of segments until followed by a <spanx style="verb">x-play</spanx>.</t>

<t>Custom messages SHOULD use a unique prefix to reduce collisions. For example: <spanx style="verb">x-twitch-load</spanx> would contain identification required to start playback of a Twitch stream.</t>

</section>
</section>
<section anchor="configuration" title="Configuration">
<t>Achieving both a high quality and low latency broadcast is difficult. Warp is a generic media transport and it is ultimately up to the application to choose the desired user experience.</t>

<section anchor="playback-buffer" title="Playback Buffer">
<t>It is RECOMMENDED that a media player use a playback buffer to ensure smooth playback at the cost of higher latency. The buffer SHOULD be at last large enough to synchronize audio/video and to account for network/encoding jitter.</t>

<t>The size of the playback buffer MAY be increased by temporarily pausing playback or reducing playback speed. The playback buffer MAY be fragmented such that unreceived media can be skipped.</t>

<t>A larger playback buffer gives the application more time to recover from starvation without user impact. A media player MAY increase the size of the playback buffer when future starvation events are anticipated.</t>

<t>Middleware SHOULD NOT use a buffer, as it will increase latency for each hop.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>Warp uses the underlying QUIC congestion control <xref target="QUIC-RECOVERY"></xref>. The default congestion control algorithm <xref target="NewReno"/> will work in many situations but can be improved.</t>

<t>This section outlines how a live media congestion control algorithm should perform, but does not recommend a specific algorithm.</t>

<section anchor="transmission-delays" title="Transmission Delays">
<t>Live media is generated in real-time and played back at a constant rate. Transmission delays cause frame delays, necessitating a larger playback buffer. Additionally, the effectiveness of prioritizing streams is reduced by high transmission delays.</t>

<t>A live media congestion control algorithm SHOULD aim to minimize delay, possibly at the expense of throughput.</t>

<t>The default QUIC congestion controller is loss-based and suffers from bufferbloat. Large queues on intermediate routers cause high transmission delays prior to any packet loss.</t>

<section anchor="application-limited" title="Application Limited">
<t>Live media is often application-limited, as the encoder limits the amount of data available to be sent. This occurs more frequently with a smaller fragment duration, as individual frames might not be large enough to saturate the congestion window.</t>

<t>A live media congestion control algorithm SHOULD have some way of determining the network capabilities even when application-limited. Alternatively, the media producer CAN pad the network with QUIC PING frames to avoid being application limited at the expense of higher bandwidth usage.</t>

<t>The default QUIC congestion controller does not increase the congestion window when application-limited. See section 7.8 of <xref target="QUIC-RECOVERY"/>.</t>

</section>
</section>
<section anchor="constant-delivery" title="Constant Delivery">
<t>Live media generates frames at regular intervals. Delaying the delivery of a frame relative to others necessitates a larger playback buffer</t>

<t>A live media congestion control algorithm SHOULD NOT introduce artificial starvation.</t>

<t>A counter-example is BBR <xref target="BBR"/>, as the <spanx style="verb">PROBE_RTT</spanx> state effectively prohibits sending packets for a short period of time for the sake of remeasuring <spanx style="verb">min_rtt</spanx>. The impact is reduced in future versions of BBR.</t>

</section>
</section>
<section anchor="configuration-prioritization" title="Prioritization">
<t>Media segments might be delivered out of order during starvation.</t>

<t>The media player determines how long to wait for a given segment (buffer size) before skipping ahead. The media consumer MAY cancel a skipped segment to save bandwidth, or leave it downloading in the background (ex. to support rewind).</t>

<t>Prioritization allows a single media producer to support multiple media consumers with different latency targets. For example, one consumer could have a 1s buffer to minimize latency, while another consumer could have a 5s buffer to improve quality, while a yet another consumer could have a 30s buffer to receive all media (ex. VOD recorder).</t>

<section anchor="live-content" title="Live Content">
<t>Live content is encoded and delivered in real-time. Media delivery is blocked on the encoder throughput, except during congestion causing limited network throughput. To best deliver live content:</t>

<t><list style="symbols">
  <t>Audio streams SHOULD be prioritized over video streams. This allows the media consumer to skip video while audio continues uninterrupted during congestion.</t>
  <t>Newer video streams SHOULD be prioritized over older video streams. This allows the media consumer to skip older video content during congestion.</t>
</list></t>

<t>For example, this formula will prioritize audio segments, but only up to 3s in the future:</t>

<figure><artwork><![CDATA[
  if is_audio:
    precedence = timestamp + 3s
  else:
    precedence = timestamp
]]></artwork></figure>

</section>
<section anchor="recorded-content" title="Recorded Content">
<t>Recorded content has already been encoded. Media delivery is blocked exclusively on network throughput.</t>

<t>Warp is primarily designed for live content, but can switch to head-of-line blocking by changing stream prioritization. This is also useful for content that should not be skipped over, such as advertisements. To enable head-of-line blocking:</t>

<t><list style="symbols">
  <t>Audio and video streams SHOULD be equally prioritized.</t>
  <t>Older streams SHOULD be prioritized over newer streams.</t>
</list></t>

<t>For example, this formula will prioritize older segments:</t>

<figure><artwork><![CDATA[
  precedence = -timestamp
]]></artwork></figure>

</section>
</section>
<section anchor="bitrate-selection" title="Bitrate Selection">
<t>Live media is encoded in real-time and the bitrate can be adjusted on the fly. This is common in 1:1 media delivery.</t>

<t>A media producer MAY reduce the media bitrate in response to starvation. This can be detected via the estimated bitrate as reported by the congestion control algorithm. A less accurate indication of starvation is when the QUIC sender is actively prioritizing streams, as it means the congestion control window is full.</t>

</section>
<section anchor="rendition-selection" title="Rendition Selection">
<t>Live media is can be encoded into multiple renditions, such that media consumers could receive different renditions based on network conditions. This is common in 1:n media delivery.</t>

<t>A media producer MAY switch between renditions at segment boundaries. Renditions SHOULD be fragmented at the same timestamps to avoid introducing gaps or redundant media.</t>

<section anchor="push-versus-pull" title="Push versus Pull">
<t>Protocols like HLS and DASH rely on the media player to determine the rendition. However, it becomes increasingly difficult to determine the network capabilities on the receiver side as media fragments become smaller and smaller. It also introduces split-brain, as the sender's congestion control may disagree with the receiver's requested rendition.</t>

<t>It is RECOMMENDED that the media producer chooses the rendition based on the estimated bitrate as reported by the congestion control algorithm. Alternatively, the media producer MAY expose the estimated bitrate if the player must be in charge.</t>

</section>
</section>
<section anchor="configuration-fragmentation" title="Fragmentation">
<t>Segments are encoded as fragmented MP4. Each fragment is a <spanx style="verb">moof</spanx> and <spanx style="verb">mdat</spanx> pair containing data for a number of samples. Using more fragments introduces more container overhead (higher bitrate), so it's up to the application to determine the fragment frequency.</t>

<t>For the highest latency: one fragment per segment. This means the entire segment must be received before any of the samples can be processed. This is optimal for content that is not intended to be decoded in real-time.</t>

<t>For the lowest latency: one fragment per frame. This means that each frame can be decoded when fully received. This is optimal for real-time decoding, however it introduces the largest overhead.</t>

<t>Fragments can be created with variable durations. However, the fragment duration SHOULD be relatively consistent to avoid introducing additional playback starvation. Likewise audio and video SHOULD be encoded using similar fragment durations.</t>

</section>
<section anchor="encoding" title="Encoding">
<t>Warp is primarily a network protocol and does enforce any encoding requirements. However, encoding has a significant impact on the user experience and should be taken into account.</t>

<t>B-frames MAY be used to improve compression efficiency, but they introduce jitter. This necessitates a larger playback buffer, increasing latency.</t>

<t>Audio and video MAY be encoded and transmitted independently. However, audio can be encoded without delay unlike video. Media players SHOULD be prepared to receive audio before video even without congestion.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources. Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer. Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order. Streams might be starved indefinitely during congestion and SHOULD be cancelled (<xref target="cancellation"/>) after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order. If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream (<xref target="cancellation"/>) after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell'>
	 <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear'>
	 <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev'>
	 <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Michael Thornburgh</t>
</list></t>

</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

