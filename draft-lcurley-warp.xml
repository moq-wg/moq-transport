<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Layered Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a layered live media transport protocol.
Media is split into layers based on the underlying media encoding.
Each layer is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important layers to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="layers"/> covers how media is encoded and split into layers.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media layers in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="layers" title="Layers">
<t>Warp is based on the concept of layered coding.
A layer is a combination of a media bitstream and a set of properties.</t>

<t><list style="symbols">
  <t>The encoder determines how to split the encoded bitstream into layers (<xref target="media"/>).</t>
  <t>Layers are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>Each layer is transferred over a QUIC stream, which are delivered independently according to the layer properties (<xref target="properties"/>).</t>
  <t>The decoder receives each layer and skips any layers that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstream is then fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.</t>

<t>Warp works by splitting the codec bitstream into layers that can be transmitted independently.
The producer determines how to split the bistream into layers: based on the track, GoP, frame/sample, or even slice.
Depending on how the layers are produced, the consumer has the ability to decode layers out of order and skip over gaps.
See the appendix for examples based on media encoding (<xref target="appendix.examples"/>).</t>

<t>TOOD specify CMAF</t>

<t>A layer MUST contain a single track.
A layer MAY contain any number of samples which MUST be in decode order (increasing DTS).
There MAY be gaps between samples, as specified by the presentation timestamp and duration within the container.</t>

<t>The goal of layers is to produce a hierarchy.
Layers MAY depend on any number of other layers and MAY overlap with other layers.</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>Warp responds to congestion by assigning each layer a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each layer are still delivered in order; this delivery order only applies to the ordering between layers.</t>

<t>The encoder determines the value assigned to each layer based the media encoding and desired user experience.
Multiple layers MAY use the same value, in which case they SHOULD be delivered via round-robin.
See the appendix for examples (<xref target="appendix.examples"/>).</t>

<t>A sender SHOULD attempt to deliver layers based on this delivery order.
This effectively involves creating a priority queue in ascending order, allocating any avaiable bandwidth to the next pending layer.
Since each layer is sent over a dedicated QUIC stream, the next QUIC packet SHOULD contain a STREAM frame for the next pending layer, repeated until the congestion window is hit.
The sender MAY ignore the delivery order for retransmits and MUST ignore it when flow control limits are reached.</t>

<t>A receiver MUST NOT assume that layers will be received in delivery order for a number of reasons:
* Newly encoded layers MAY have a smaller delivery order than outstanding layers.
* Packet loss or flow control MAY delay the delivery of individual streams.
* The sender might not support QUIC stream prioritization.</t>

<t>Layers arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble layers into decode order and it SHOULD skip layers after a configurable duration.
The amount of time the decoder is willing to wait for a layer (buffer duration) is what ultimately determines the latency.</t>

<t>A proxy MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.
This is NOT RECOMMENDED unless the proxy knows additional information about the media.
For example, a proxy could use the PTS as the delivery order to enable head-of-line blocking for content that should not be skipped, like an advertisement.</t>

</section>
<section anchor="properties" title="Properties">
<t>Each layer has properties to go along with its contents.
These are written on the wire and SHOULD be parsed by any Warp intermediaries.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
A numeric identifier for the layer.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
A numeric value indicating the delivery order (<xref target="delivery-order"/>).
A sender SHOULD transmit layers with smallest value first, as bandwidth permits.
If two layers use the same value, they SHOULD be round-robined.
Note that layers can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
A list of numeric layer IDs.
This informs the decoder that it MUST receive and process the dependency layers first.
The decoder MAY support stream processing, such that it does not need to fully receive the dependency layers first.
The layer SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">cache</spanx>.
TODO Indicates the layer should be cached for some amount of time since last access. What about fragments with an unbounded age? Should we send an <spanx style="verb">expire</spanx> message instead?</t>
  <t><spanx style="verb">expires</spanx>.
TODO Indicates the layer should be dropped after some amount of time (ex. <spanx style="verb">RESET_STREAM</spanx>). Do we need clock sync for this? How does this interact with <spanx style="verb">cache</spanx>?</t>
  <t><spanx style="verb">timestamp</spanx>.
TODO The presentation timestamp of the earliest (not always first) frame in the layer. What does an intermediary need this for?</t>
  <t><spanx style="verb">track</spanx>
TODO The track identifier to be used in conjunction with the TRACK message.</t>
</list></t>

<t>See the appendix for some example layers and properties. <xref target="appendix.examples"/></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The consumer will receive multiple layers over the network in parallel.
The decoder MUST synchronize layers using presentation timestamps within the bitstream.
The decoder might not support decoding each layer independently, so the consumer MAY need to reorder prior to passing a bitstream to the decoder.</t>

<t>Layers are NOT REQUIRED to be aligned within or between tracks.
For example, a low quality rendition may have more frequent I-frames, and thus layers, than a higher quality rendition.
A decoder MUST be prepared to skip over any gaps between layers.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

<t>TODO define auth inside the protocol?</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message. TODO better name.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a layer, the header MUST match the layer properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<t>TODO define more error codes</t>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document varint identifier
TODO more message types</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>LAYER <xref target="layer"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in layer properties (<xref target="properties"/>).</t>

<t>TODO better name
TODO document wire format
TODO use QPACK?</t>

</section>
<section anchor="layer" title="LAYER">
<t>A <spanx style="verb">LAYER</spanx> message consists of the layer bitstream.
A <spanx style="verb">LAYER</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the layer properties (<xref target="properties"/>).</t>

<t>TODO document CMAF
TODO document wire format
TODO support multiple container formats</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

<t>TODO document wire format</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving layers from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO expand</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.examples" title="Appendix A. Layer Examples">
<t>Warp offers a large degree of flexability on how layers are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of media encoding and some options available.</t>

<section anchor="recommended" title="Recommended">
<t>Before explaining all of the options, there is a recommended approach:</t>

<t><list style="symbols">
  <t>a video layer per GoP (<xref target="appendix.gop"/>)</t>
  <t>an audio layer at roughly the same timestamp (<xref target="appendix.segments"/>)</t>
</list></t>

<t>The recommended delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>TODO full section on delivery order.</t>

</section>
<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Traditionally, these tracks could be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so they must be demuxed.</t>

<t>The simplest configuration is a single, continuous layer per track.
This allows tracks to be prioritized during congestion, although no media can be dropped.
The next section covers how to further split layers based on the type of media.</t>

</section>
<section anchor="video" title="Video">

<section anchor="encoding" title="Encoding">
<t>Video is a sequence of frames with a display timestamp.
To improve compression, frames are encoded as deltas and can reference number of frames in the past (P-frames) and/or in the future (B-frames).
A frame with no dependencies (I-frame) is effectively an image file and is a seek point.</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>Another common encoding structure is to use B-frames in a fixed pattern, which is easier for hardware encoding.
B-frames reference one or more future frames, which improves the compression ratio but increases latency.</t>

<t>This example is referenced in later sections:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency still have a lot of options for references.</t>

</section>
<section anchor="decode-order" title="Decode Order">
<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its dependencies.
This is only relevant for B-frames as they must be buffered until the frame they reference has been flushed.</t>

<t>A layer MUST be in decode order.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
encode order: I B P B P I B P B P I B P ..
decode order: I P B P B I P B P B I P B ..
]]></artwork></figure>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and the frames that directly or indirectly reference it.
Each GoP can be decoded independently and thus can be transmitted independently.
It is also safe to drop the tail of the GoP (in decode order) without causing decode errors.</t>

<t>A layer MAY consist of an entire GoP.
A layer MAY consist of multiple sequential GoPs.</t>

<t>Our example GoP structure would be split into three layers.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>The concept of layers is borrowed from scalable video coding (SVC).
When SVC is enabled, the encoder produces multiple bitstreams in a hierarchy.
Dropping the top layer degrades the user experience in a configured way, such as reducing the resolution, picture quality, and/or frame rate.</t>

<t>A layer MAY consist of an entire SVC layer.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
                layer 3              layer 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

                layer 2              layer 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

                layer 1              layer 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the producer can split a GoP into multiple layers based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>A layer MAY consist of a single frame.</t>

<t>Our example GoP structure could be split into thirteen layers:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of layers, frames can be appended to a layer they depend on.
Layers are delivered in order so this is simpler and produces the same user experience.</t>

<t>A layer MAY consist of multiple frames within the same GoP.</t>

<t>The same GoP structure can be represented using eight layers:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of layers by combining some frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the layer, or within a dependency layer.
For example, non-reference frames can have their own layer so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six layers, although we've removed our ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that this is identical to our SVC example; we've effectively implemented our own temporal coding scheme.</t>

</section>
<section anchor="slices" title="Slices">
<t>Frames actually consist of multiple slices that reference other slices.
It's conceptually simpler to work with frames instead of slices, but splitting slices into layers may be useful.
For example, intra-refresh splits an I-frame into multiple I-slices (TODO terminology) and spread over multiple frames to smooth out the bitrate.
TODO are slices necessary?</t>

<t>A layer MAY consist of a single slice.
A layer MAY consist of multiple slices that are part of the same GoP.</t>

</section>
<section anchor="init" title="Init">
<t>For the most byte-conscious applications, initialization data can be sent over its own layer.
Multiple layers can depend on this initialization layer to avoid redundant transmissions.
For example: this is the init segment in CMAF (<spanx style="verb">moov</spanx> with no samples), which contains the SPS/PPS NALUs for h.264.</t>

<t>A layer MAY consist of no samples.</t>

<t>Our example layer per GoP would have an extra layer added:</t>

<figure><artwork><![CDATA[
     layer 2         layer 3      layer 4
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|                     init
+-----------------------------------------
                     layer 1
]]></artwork></figure>

<t>An initialization layer MUST be cached in memory until it expires.
TODO How do we do this?</t>

</section>
</section>
<section anchor="audio" title="Audio">

<section anchor="encoding-1" title="Encoding">
<t>Audio is dramatically simpler than video as it is not typically not delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>In the below diagrams, each audio frame is denoted with an S.
The encoder spits out a continuous stream of samples:</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S
]]></artwork></figure>

</section>
<section anchor="simple" title="Simple">
<t>The simplest configuration is to use a single layer for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<t>A layer SHOULD consist of multiple audio frames.</t>

<figure><artwork><![CDATA[
          layer 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

</section>
<section anchor="periodic-refresh" title="Periodic Refresh">
<t>An improvement is to periodically split audio samples into separate layers.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio layers is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a layer for each audio frame because of this overhead.</t>

</section>
<section anchor="appendix.segments" title="Segments">
<t>Video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio layer at each video I-frame.</t>

<figure><artwork><![CDATA[
     layer 1         layer 3      layer 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
     layer 2         layer 4      layer 6
]]></artwork></figure>

<t>This is effectively how HLS/DASH segments work, with the exception that the most recent layers are still pending.</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAIHQVWMAA91963IbR5bmfzxFrfyjxR0ApiTbbdMz4aZIWmZYFy5JtaNj
ZqNVABJEtQpVcF1IoSV17EPsA+yzzKPMk+z5ziUzq1CgZG9MTMSy2xAuVXk5
ea7fOZk1mUxGTdbk7ih58EtabZJJ8jzdusotkufZrUteuEWWJtdVWtSbsmoe
jNLZrHK3R8kvx5cXo0U5L9I13buo0mUzyedtlbvt5I4amuRp4+pmtKB/jpL3
p8fXZx9Hc/pwU1bboyQrluVolG2qo6Sp2rp5fHj43eHjUVq59Ch55gpXpfno
rqze3lRluzlKzouF2zh6KZrkqp2ts7rOymL01m3pogV+b1xVuGZyipGMRnWT
Fou/pnlZUO9bV4/qdVo1f/21LWlUR0lRjjbZUfKvTTkfJzVNrHLLmt5t1/KG
JrZON5usuPmfo1HaNquyOholyYT+S2js1MLzaXLCs+WvhArP27cu/rasbtIi
+3va0FCPkuu7rJmv+Ae3TrP8KHmbvXMg0+JPN/hiOi/Xo24vP0+Ti/YmK6JO
fs6qLM+jr7u9vHBNGveRvc2qP63py4HWr6bJSyJT+rYl4kRdXLWrtO7/1O3m
JKvnZdxPXcjlf5rjF+lsVJTVmm64dSDe/3h9fnKUXP548t3h4aF+nlyenbz6
89nlX+yHx/TDL27mGY5WdnI6zVyznNy5WYOvJ6um2TzBVM6vXj198eOPRzwO
4+Jz4izutSySxs1XRZmXN9vkP/7X/05OygWtaFIuk7RdZOXkNqvbNE/K2d/c
vKn5kgvikuTR4yO0nTxNa5OAH7PcJT9yww+4O+Hrx4ePvp48ekycbL3KXE9e
HH/esCaT5EWbN9maeyGWy7O5XCSXJw9fXJw9mxwf4EoZ3HdE/XK9pkv234T+
D/Apqd3NmoSG5Jmv7g7+8eHk8Al989LdXbqi5EX45utvsQhPn14K7edptbhz
eT7J5vPqZkLiP5mXxQ3JNnWIt01V5hNauNFoQmNMZzWt0pxE8HqV1RCkFv0n
C7fMClcnzcol87Jyycyt0tuMRohRQvWMkzTJVffk0D0yvcZYIdlUJclrmU9H
sibUfE1Tb4iZm1JurZMZrdkiAZGpo5YURpVvsejSmCvmzAPT0Vk6X8k9aIc7
WWcN6JQFVZNvk/KWrkiZWROamUvX01H0oU5IZdHIaCJZk/3dLWgWeV7eocvc
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
j4zFBOsu5TR5wIrnAZ7apYd3OH7CUZbeVLy5j50ZyYd7UJuMR9lER4VeTTvI
eb1hSW6b7oG+9ujI+BmIWKOrZM//ZAXZmjDxPpEV9btUVOnJQvsMscwhzo1C
5dcOz7MpHE6h53IzfcAipoNNH3iao8Fpnecydp8zpb/Z7hPsByIqQtvzURxS
vfVry3uKUO1W9WOMsewNQTRsR3rYA1lNcYQTEncUd7Q+HYC1Iw/3yRXJ4/5l
uPdGv0YXupMkuRQ7yaIncbyoUzn8Nt5vorBDh7nZlnoX0zBjXq+bLGTntA6q
tzeNT0FJUe5riW0unu1sUoHNEs9F6pW5EPEWDcg5XP+Z8PRVEv9/7+ffDE8z
efSUGX1qYigEqjUP4k8hHCf+NFj1EwIcA0MM+qnLNbATTI8lSYflS3TEzAnH
27MLQqsizlboFqVyfA2SZv2joEgeSCMo+s5ymg5SX8yKKvjJUdCka2DY/knD
pZZSy2DlebPGa1xtfpvme04O8fNGwWyvzooJIEpdx/FpPuoY5K//y/noP8XK
3+OPfBV/+CZi414VBGpKfnp+9SU//8pXSMox9b5s3L1DYMBFy51Tk1GhGR4r
H0441rpsfXo8HlWHgscTeypLWdWj90eCArjFvzxYks10Dz5Kqdfo/wKjdcoT
EIQAAA==

-->

</rfc>

