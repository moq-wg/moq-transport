<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Layered Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a layered live media transport protocol.
Media is split into layers based on the underlying media encoding.
Each layer is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important layers to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="layers"/> covers how media is encoded and split into layers.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t>TODO definitions</t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media layers in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="layers" title="Layers">
<t>Warp is based on the concept of layered coding.
A layer is a combination of a media bitstream and a set of properties.</t>

<t><list style="symbols">
  <t>The encoder determines how to split the encoded bitstream into layers (<xref target="media"/>).</t>
  <t>Each layer is transferred over a QUIC stream, which are delivered independently according to the layer properties (<xref target="properties"/>).</t>
  <t>The decoder receives each layer and skips any layers that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstream is then fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.</t>

<t>Warp works by splitting the codec bitstream into layers that can be transmitted independently.
The producer determines how to split the bistream into layers: based on the track, GoP, frame/sample, or even slice.
Depending on how the layers are produced, the consumer has the ability to decode layers out of order and skip over gaps.
See the appendix for examples based on media encoding (<xref target="appendix.examples"/>).</t>

<t>TOOD specify CMAF</t>

<t>A layer MUST contain a single track.
A layer MAY contain any number of samples which MUST be in decode order (increasing DTS).
There MAY be gaps between samples, as specified by the presentation timestamp and duration within the container.</t>

<t>The goal of layers is to produce a hierarchy.
Layers MAY depend on any number of other layers and MAY overlap with other layers.</t>

</section>
<section anchor="properties" title="Properties">
<t>Each layer has properties to go along with its contents.
These are written on the wire and inform how they layer should be transmitted at each hop.
This is primarily for the purpose of supporting intermediaries, but some of this information may also be used by the decoder.</t>

<t>All currently defined properties are optional.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
A numeric identifier for the layer.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
A numeric priority such that the smaller values take priority.
A sender SHOULD transmit layers with smallest value first, effectively starving layers with larger values during congestion.
If two layers use the same value, they SHOULD be round-robined.
Note that layers can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
A list of numeric layer IDs.
This informs the decoder that it MUST receive and process the dependency layers first.
The decoder MAY support stream processing, such that it does not need to fully receive the dependency layers first.
The layer SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">cache</spanx>.
TODO Indicates the layer should be cached for some amount of time since last access. What about fragments with an unbounded age? Should we send an <spanx style="verb">expire</spanx> message instead?</t>
  <t><spanx style="verb">expires</spanx>.
TODO Indicates the layer should be dropped after some amount of time (ex. <spanx style="verb">RESET_STREAM</spanx>). Do we need clock sync for this? How does this interact with <spanx style="verb">cache</spanx>?</t>
  <t><spanx style="verb">timestamp</spanx>.
TODO The presentation timestamp of the earliest (not always first) frame in the layer. What does an intermediary need this for?</t>
  <t><spanx style="verb">track</spanx>
TODO The track identifier to be used in conjunction with the TRACK message.</t>
</list></t>

<t>See the appendix for some example layers and properties. <xref target="appendix.examples"/></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The consumer will receive multiple layers over the network in parallel.
The decoder MUST synchronize layers using presentation timestamps within the bitstream.
The decoder might not support decoding each layer independently, so the consumer MAY need to reorder prior to passing a bitstream to the decoder.</t>

<t>Layers are NOT REQUIRED to be aligned within or between tracks.
For example, a low quality rendition may have more frequent I-frames, and thus layers, than a higher quality rendition.
A decoder MUST be prepared to skip over any gaps between layers.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

<t>TODO define auth inside the protocol?</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message. TODO better name.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a layer, the header MUST match the layer properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<t>TODO define more error codes</t>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document varint identifier
TODO more message types</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>LAYER <xref target="layer"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in layer properties (<xref target="properties"/>).</t>

<t>TODO better name
TODO document wire format
TODO use QPACK?</t>

</section>
<section anchor="layer" title="LAYER">
<t>A <spanx style="verb">LAYER</spanx> message consists of the layer bitstream.
A <spanx style="verb">LAYER</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the layer properties (<xref target="properties"/>).</t>

<t>TODO document CMAF
TODO document wire format
TODO support multiple container formats</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

<t>TODO document wire format</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving layers from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO expand</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.examples" title="Appendix A. Layer Examples">
<t>Warp offers a large degree of flexability on how layers are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of media encoding and some options available.</t>

<section anchor="recommended" title="Recommended">
<t>Before explaining all of the options, there is a recommended approach:</t>

<t><list style="symbols">
  <t>a video layer per GoP (<xref target="appendix.gop"/>)</t>
  <t>an audio layer at roughly the same timestamp (<xref target="appendix.segments"/>)</t>
</list></t>

<t>TODO section on prioritization
* audio should be delivered before video
* for new media should be delivered before old media, or the opposite if reliability is desired</t>

</section>
<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Traditionally, these tracks could be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so they must be demuxed.</t>

<t>The simplest configuration is a single, continuous layer per track.
This allows tracks to be prioritized during congestion, although no media can be dropped.
The next section covers how to further split layers based on the type of media.</t>

</section>
<section anchor="video" title="Video">

<section anchor="encoding" title="Encoding">
<t>Video is a sequence of frames with a display timestamp.
To improve compression, frames are encoded as deltas and can reference number of frames in the past (P-frames) and/or in the future (B-frames).
A frame with no dependencies (I-frame) is effectively an image file and is a seek point.</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>Another common encoding structure is to use B-frames in a fixed pattern, which is easier for hardware encoding.
B-frames reference one or more future frames, which improves the compression ratio but increases latency.</t>

<t>This example is referenced in later sections:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  /   \ /   \     /   \ /   \     /   \
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>Note that the B-frames reference I and P frames in this example, despite the lack of an arrow.
TODO better ASCII art</t>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency still have a lot of options for references.</t>

</section>
<section anchor="decode-order" title="Decode Order">
<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its dependencies.
This is only relevant for B-frames as they must be buffered until the frame they reference has been flushed.</t>

<t>A layer MUST be in decode order.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
encode order: I B P B P I B P B P I B P ..
decode order: I P B P B I P B P B I P B ..
]]></artwork></figure>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and the frames that directly or indirectly reference it.
Each GoP can be decoded independently and thus can be transmitted independently.
It is also safe to drop the tail of the GoP (in decode order) without causing decode errors.</t>

<t>A layer MAY consist of an entire GoP.
A layer MAY consist of multiple sequential GoPs.</t>

<t>Our example GoP structure would be split into three layers.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>The concept of layers is borrowed from scalable video coding (SVC).
When SVC is enabled, the encoder produces multiple bitstreams in a hierarchy.
Dropping the top layer degrades the user experience in a configured way, such as reducing the resolution, picture quality, and/or frame rate.</t>

<t>A layer MAY consist of an entire SVC layer.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
                layer 3              layer 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

                layer 2              layer 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

                layer 1              layer 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the producer can split a GoP into multiple layers based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>A layer MAY consist of a single frame.</t>

<t>Our example GoP structure could be split into thirteen layers:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of layers, frames can be appended to a layer they depend on.
Layers are delivered in order so this is simpler and produces the same user experience.</t>

<t>A layer MAY consist of multiple frames within the same GoP.</t>

<t>The same GoP structure can be represented using eight layers:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of layers by combining some frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the layer, or within a dependency layer.
For example, non-reference frames can have their own layer so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six layers, although we've removed our ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that this is identical to our SVC example; we've effectively implemented our own temporal coding scheme.</t>

</section>
<section anchor="slices" title="Slices">
<t>Frames actually consist of multiple slices that reference other slices.
It's conceptually simpler to work with frames instead of slices, but splitting slices into layers may be useful.
For example, intra-refresh splits an I-frame into multiple I-slices (TODO terminology) and spread over multiple frames to smooth out the bitrate.
TODO are slices necessary?</t>

<t>A layer MAY consist of a single slice.
A layer MAY consist of multiple slices that are part of the same GoP.</t>

</section>
<section anchor="init" title="Init">
<t>For the most byte-conscious applications, initialization data can be sent over its own layer.
Multiple layers can depend on this initialization layer to avoid redundant transmissions.
For example: this is the init segment in CMAF (<spanx style="verb">moov</spanx> with no samples), which contains the SPS/PPS NALUs for h.264.</t>

<t>A layer MAY consist of no samples.</t>

<t>Our example layer per GoP would have an extra layer added:</t>

<figure><artwork><![CDATA[
     layer 2         layer 3      layer 4
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|                     init
+-----------------------------------------
                     layer 1
]]></artwork></figure>

<t>An initialization layer MUST be cached in memory until it expires.
TODO How do we do this?</t>

</section>
</section>
<section anchor="audio" title="Audio">

<section anchor="encoding-1" title="Encoding">
<t>Audio is dramatically simpler than video as it is not typically not delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>In the below diagrams, each audio frame is denoted with an S.
The encoder spits out a continuous stream of samples:</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S
]]></artwork></figure>

</section>
<section anchor="simple" title="Simple">
<t>The simplest configuration is to use a single layer for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<t>A layer SHOULD consist of multiple audio frames.</t>

<figure><artwork><![CDATA[
          layer 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

</section>
<section anchor="periodic-refresh" title="Periodic Refresh">
<t>An improvement is to periodically split audio samples into separate layers.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio layers is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a layer for each audio frame because of this overhead.</t>

</section>
<section anchor="appendix.segments" title="Segments">
<t>Video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio layer at each video I-frame.</t>

<figure><artwork><![CDATA[
     layer 1         layer 3      layer 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
     layer 2         layer 4      layer 6
]]></artwork></figure>

<t>This is effectively how HLS/DASH segments work, with the exception that the most recent layers are still pending.</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAMK5UmMAA91963IcR7Le/3mKMvVjCZ+ZEUhKWgmyQwsCoIgQLzAArmLD
dixremowvejpnu0LgFmSG36I8wDnWfwofhLnl5l16Z4BSMlx4kQYuwLn0nXL
zMrLl1mFyWQyavO2cAfm0a+2XpuJeWU3rnZz8yq/cea1m+fWXNa2bNZV3T4a
2dmsdjcH5tfD87PRvMpKu6K289ou2kmRdXXhNpNb6mhS2NY17WhO/xyYD8eH
lyefRhm9uarqzYHJy0U1GuXr+sC0dde0T/f3f9h/OrK1swfmZ1e62haj26q+
vqqrbn1gTsu5Wzv6Vbbmoput8qbJq3J07Tb00Bzft64uXTs5xkxGo6a15fyv
tqhKGn3jmlGzsnX71793Fc3qwJTVaJ0fmP/eVtnYNLSw2i0aerVZyQta2Mqu
13l59T9HI9u1y6o+GBkzof8MzZ16eDU1R7xa/kio8Kq7dumnVX1ly/wftqWp
HpjL27zNlvyFW9m8ODDX+Z0DmeZ/usIH06xajfqj/DI1Z91VXiaD/JLXeVEk
H/dHee1am46RX+f1n1b04Y7eL6bmDZHJXndEnGSIi25pm+FX/WGO8iar0nGa
Uh7/U4ZvZLBRWdUranDjQLz/9u706MCcvzj6YX9/X99Pzk+O3v755Pwv/oun
9MWvbhYEjjg7OZ7mrl1Mbt2sxceTZduun2Eppxdvn79+8eKA5+Gl+JQki0et
StO6bFlWRXW1Mf/nf/2rOarmxFFTLYzt5nk1ucmbzhammv3NZW3Dj5yRlJgn
Tw/Qt3luG78DXuSFMy+440c8nMj10/0n306ePCVJ9qPKWo9eH37ZtCYT87or
2nzFo5DIFXkmD8nj5vHrs5OfJ4d7eFIm9wNRv1qt6JH7G2H8Pbwzjbta0aah
/cxP9yf/dH+y/4w+eeNuz11ZMRO++/Z7MOH583OhfWbr+a0rikmeZfXVhLb/
JKvKK9rbNCBetnVVTIhxo9GE5mhnDXEpoy14ucwbbKQO45u5W+Sla0y7dCar
amdmbmlvcpohZgnVMzbWFKp7CugeWV7rRcGs64r2a1VMR8IT6r6hpbckzG0l
TRszI57NDYhMA3WkMOpiA6ZLZ67MWAamoxObLaUN+uFBVnkLOuVR1RQbU93Q
E5aF1dDKnF1NR8mbxpDKopnRQvI2/4eb0yqKorrFkIVrGpOvMHdLFNAJ0lRn
jlrb+gYTrUl3Vus1vZx3NVpF4k6Foqt8Pi8ckferr6Dm6mreZfh6xPqaJm8f
JhdRgkSia/OC5icM4AWQtoSCjc99+IDPP32icT98WFUkyyxUnz7RnG546tR0
ZjPWyeXc0IY3NT9iC+YnUY45OaX2strYdlnd6gxpxswGJz1ssRCt/97lWb8t
T5madmAvPcvrXBBvuFO0WRG5LZFuOKZ8ynzy46p43Oa1mwphL10NXtJ8jiGo
OVbVQIadIRtjYGQa8+j1u4vLR2P517x5y6/PT2hq5yfHeH3x8vDVq/BipE9c
vHz77tVxfBVbHr19/frkzbE0pk9N76PRo9eHf6FvMKtHb88uT9++OXz1iEhF
k0+3FlYmUpXDCq5rBzG2zWjumqzOZyzT5vnR2f/+tyffEJf/E+3yp0+e/ECE
kjffP/njN/TmdulKGa0qSfLlLdFpMyIV42yNXki4TWbXeWsLMpNkJRoicmmW
TigpiokaC5uYqDvnG6c2c7RdqO3l2+O3oiU88UdfmddBCplLr0hvldlmdEoT
MWtXL0hvgzcFbbtb6JWuoH3ksB3qdFOQ/IPfDVk3SCwRqoUsrXkvufmU+Uxb
ftJWE/rHFDIOWwozqys7z2yDkdA/0XlBhnseKdV0bEHABK9g+EvVKuyqYFp2
Q8L9Doag7UoaotiM/S4kYbU03Rtb53ZGu6ld0h67Wq67dgztQkY4p4HmHXO6
pyIOSWmt1i3GpK/84mXdha2v6A0pAOVB6N9v/lneMkEySxxrzN8717F6ZOWt
7+jL0lQZOXe0qs0teC1MJcVn2yURpL11Tj6QHVbz8ueOX09HZDeNu7OrNSwh
nkpMFkuYeXtBXlh27VoYgdt8kRtaPokPsTWniRO7S7LIZ2PoyyvxDokcvdmA
1nlLBDldkHuHRleGpa50oPKtWdTE/oY6JBGe8Ryg5EWZCPuF36TdWH1j9Y4X
wk1aS85dAcrXaGLrGvKlpHV5TWxytGJSN1VNWyMvM7IPDdsBkabp6C1R8G/V
jA1ORXq9zFekknl0DEqkpAm0nvJO9uKC3CtmLmlx8lCv8zU3kNlhj5p1RRJG
TMUmWnYwig7SSfK6zMnIWRWGoOfBzjnpCJJYVuGO7EXJdPAMx7f1KtjrsIBf
HTeOHMgKS2MvNsTevGmjnfVjNaLYSdaM+v65u99GDy3SwWj0n83l0dlEGgy7
fuzupub88jWJxctXF2NzfHjxck/scbXuSPb9fhH+NGSKSerydpM6EA5m+Gva
UQ0pJ1aUIrYkaZBjImEBIdj4yalYEdvJKJMy2PAiaJJivaajl9Wtu4Hk0ueN
S6Ybt3HjHBQkWLTMr5bQVapwWmxYckV7E68RJJCwoSXpSuUddEpkX+MS/k1B
t3fHn6EbkY087fPLo7G5OL/cY842+dxNmtaJjJHm6njHkGRihRiOurmhh2gn
3Cbz5kdID5DYqGSubElmF/o+kIT7HMgikbKkJekiIMXsD9JeZbdVVURUeEYd
zjE1SdVrgw8yx7pvQeIPNwUfkXi61QyKFpNfVTBTrNvsHHufwhRSSnckE7T0
q5IUD1EBbl9t80alH2LjwmTMPF/QU+Szb7jLZVe3jRjeiiySndFuhYSNDs1V
heBCdzRHyLrzicXiS9Ga8MCM1JWYMQrKrAiqG/hvzJ0Wiqgm8zuHMdi5hVPb
wAuFnVMFQbGaI/kqM4dR4VGNYYhp4aIGyayJnaRwtyXSkCg1eJJ4r53JKkgg
sY2JGD1PeIf5YY+X9pQ6yBvdVbtcXTLv70o0bijyv9yWFNqVzYZEc4UVeflw
8x+NgycfHkPkmrd/oNmRW1KS/iOGX6xdlttCg1e0rxYkt9D1VTU3bCvGZta1
cCJmWBxrdrIsf4CvCkPMcUBh11jkLel+OPRQGlWRz62uIDFzMGNQLTmRekVb
vAVTSWZs6aquIeblvHJzQytMNuFY1Rnx9OsKYUfWNW21wl6OK5TohANZ0aDB
QYH6ufR+Tn/4FoZiMIc5qWzywcjO9ubx6tWE1Sn/elzJtoVuFe+hbJu93zjB
m9zdYm6YXDNkrHjmtZ3T1it4Vgty69lPJIkmS55ursL9SNJH0QHLDysA9bcw
T9YH3V10YEhkeM8taJNCzapRjnq7dCL5K0uD0H9EtbVlh4gCtOxadV+ckruj
abSkGnQWrBeah3d7piEkO2Mwzllbdys8SjZgQnxzzdSwiC6EBGz2joJwsZoq
hVNe6QfW6T53al0i+TLX88tggXPRZ6qieMNbEm5R0OQoIUgyR8dvzDVUMoIn
PFLVJO/eiNAHb4way1ripaVvm0MxwJ9OHMF5cDC3tvxPRDO4R6mmg5ITcrFK
DPTxVmcussBzYU/CsvMH1EMcisGkmVQkOj5IJLoeYgqL/KpjaQoGDHqng99l
hTYkj25SLRaeuBwo1OZxstfIYi6rCrPTUWXJqeffKtl6Dg80LjAOWl0tApWD
XQpJeOKax7Jr+qPA/xQVRH3DUG73Tw7DPSPIhhI3hn25W8u7LH0k2JobCNOi
pr1NO6aYAKHi9gXZkg0PTY617uyxqn5S9/Pw0IThDzxo4Y7TTPzD2FMkdnGv
+aCpwS4OemHqEY+E4coNd6NOMSvrhUg2TTz6PH3tArvPqyQX40bWQXHBH1rz
qKEd5x4RNdjPY8NBu9OF7tA1tw5mH2utKN5S151IReZxrPhE27hioaEl6wLq
RWLN1AxTD7VYLQphgdiB8kQLdhwotl1Ysutkg0gdVSuXeMA7fN+9/kqMy5nW
WCIjHndZ0TXiPHJMDob01Ql2PTkQtDTR0CAAbT5P04HK4GG2YwrR+ewTJFsU
ofFaYFx68o4YSL4cLRz/kqKh3xcv3tFv12ZquboMERSU48vLy/sc2Dx1kNPJ
FXAzye3k/ZsLMsUd8Wi0vNfOluzSj4XXPa7OupzCe1GBcW/FYZkct4g3YZWC
48QmYqCXyJKQ9zSfDnyCAXHgq9C4xPnGDWMhqJJM9pXGYhrOkeNOLRArM/ii
iIQHERd53bTi7IquyfJGfR6ZtHSGYC0zIgoNvYFtw5JZKpfV+mGLBn+v3VLF
jQwuMaHJGA4tieiHFDzlQFPZvolDDw9S+TYWn5BdsICjer+fpsNfkIBg7Nsa
EG3pOQ/8DqReOstepecIVtKfnfoDNJ+udsrJwfyh9BCww/kH9vC1GMdo+DDi
IodEzWHBSps42bZoqn7vScgSIjT2SAK9Le9xiAEZqJ6FIAWnNrwR+ic+E9sh
Bi0lUdcEGLjXBY2TuTVHFx5T98j3YYS9LQKgmS5F0A81KKTJ2KsXRUKqmrta
sxvWMkERmieATwIZqDkUYHfgC2ivKWL/GNAtDfrp096UOt0BzBMxsIBtKH7s
IQ5GFDn02ALwbZaRgCk8JmgG+o5LwQTiO53FpWweXpoGlo3sDmnOyPV1vm4Y
G/DQPhg/r3inKT4EZAqmk8bQ7ngAWDbGIGh3BBIqdxu2rNA/sDuiBwLlmrhN
kWa5FrWZELYRV38RgS2/DJUMscVEHtISC8TrMxd8aahqT2hxj9lZGHu4jwML
CeFoxAF+Su/IuK0YFSZbW5A7LYBKTCWADOpxERnGwcYEEJQ2IYhHrhh745ZN
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
Nvq/b/JkUXV0AAA=

-->

</rfc>

