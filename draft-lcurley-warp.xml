<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol.
Media is split into segments based on the underlying media encoding.
Each segment is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="segments"/> covers how media is encoded and split into segments.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media segments in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided intermediaries are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over the network somewhat independently.
A segment is a fragmented MP4 {ISOBMFF} containing a single track and any number of frames/samples.
Each segment has a set of properties, written separately on the wire, that dictates how it should be delivered.</t>

<t><list style="symbols">
  <t>The encoder determines how to split the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>Each segment is transferred over a QUIC stream, which are delivered independently according to the segment properties (<xref target="properties"/>).</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The bitstream is then fed to the decoder on the other end, after being transported over the network, in the same order its produced.
The problem, as explained in motivation (<xref target="latency"/>), is that networks cannot sustain a continuous rate and thus queuing occurs.</t>

<t>Warp works by splitting the codec bitstream into segments that can be transmitted independently.
The producer determines how to split the bistream into segments: based on the track, GoP, frame/sample, or even slice.
Depending on how the segments are produced, the consumer has the ability to decode segments out of order and skip over gaps.</t>

<t>See the appendix for an overview of media encoding (<xref target="appendix.encoding"/>) and for fragmentation examples (<xref target="appendix.examples"/>)</t>

<t>A segment MUST contain a single track.
A segment MAY contain any number of samples which MUST be in decode order (increasing DTS).
There MAY be gaps between samples within a segment.</t>

<t>Segments MAY depend on any number of other segments and MAY overlap with other segments.
This allows the creation of a hierarchy for more sophisticated encoding and delivery (ex. SVC).</t>

<t>TOOD specify CMAF</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>Warp responds to congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>The encoder determines the value assigned to each segment based the media encoding and desired user experience.
Multiple segments MAY use the same value, in which case they SHOULD be delivered via round-robin.
See the appendix for examples (<xref target="appendix.examples"/>).</t>

<t>A sender SHOULD attempt to deliver segments based on this delivery order.
This effectively involves creating a priority queue in ascending order, allocating any avaiable bandwidth to the next pending segment.
Since each segment is sent over a dedicated QUIC stream, the next QUIC packet SHOULD contain a STREAM frame for the next pending segment, repeated until the congestion window is hit.
The sender MAY ignore the delivery order for retransmits and MUST ignore it when flow control limits are reached.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:
* Newly encoded segments MAY have a smaller delivery order than outstanding segments.
* Packet loss or flow control MAY delay the delivery of individual streams.
* The sender might not support QUIC stream prioritization.</t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the latency.</t>

<t>A proxy MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.
This is NOT RECOMMENDED unless the proxy knows additional information about the media.
For example, a proxy could use the PTS as the delivery order to enable head-of-line blocking for content that should not be skipped, like an advertisement.</t>

</section>
<section anchor="properties" title="Properties">
<t>Each segment has properties to go along with its contents.
These are written on the wire and SHOULD be parsed by any Warp intermediaries.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An optional, numeric identifier for the segment.
This value is only used for association and identification; a receiver MUST NOT assume it is monotically increasing.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
An optional, numeric value indicating the delivery order (<xref target="delivery-order"/>).
A sender SHOULD transmit segments with smallest value first, as bandwidth permits.
If two segments use the same value, they SHOULD be round-robined.
Note that segments can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An optional list of dependencies segments by ID.
The decoder SHOULD process the specified dependencies first.
The decoder MAY support stream processing via the decode timestamp (DTS), such that it does not need to fully receive the dependency segments first.
The segment SHOULD have a larger <spanx style="verb">order</spanx> than its dependencies, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">track</spanx>.
A numeric identifier of the track.
This MAY be different than the track ID within the container.</t>
</list></t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel.
The decoder MUST synchronize segments using presentation timestamps within the bitstream.
The decoder SHOULD use a buffer to reorder frames/samples from separate segments into decode order.</t>

<t>Segments are NOT REQUIRED to be aligned.
A decoder MUST be prepared to skip over any gaps between segments.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a segment, the header MUST match the segment properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>SEGMENT <xref target="segment"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in segment properties (<xref target="properties"/>).</t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of the segment bitstream.
A <spanx style="verb">SEGMENT</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the segment properties (<xref target="properties"/>).</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving segments from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.encoding" title="Appendix A. Video Encoding">
<t>In order to transport media, we first need to know how media is encoded.
This section is an overview of media encoding.</t>

<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a cooresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Tracks can be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so this is not allowed.
Each Warp segment MUST contain a single track.</t>

</section>
<section anchor="appendix.init" title="Init">
<t>Media codecs have a wide array of configuration options.
For example, the resolution, the color space, the features enabled, etc.</t>

<t>Before playback can begin, the decoder needs to know how the configuration.
This is done via a short payload at the very start of the media file.
The initialization payload can be cached and reused between segments with the same configuration.</t>

</section>
<section anchor="appendix.video" title="Video">
<t>Video is a sequence of pictures (frames) with a presentation timestamp (PTS).</t>

<t>An I-frame is a frame with no dependencies and is effectively an image file.
These frames are usually inserted at a frequent interval to support seeking or joining a live stream.
However they can also improve compression when used at hard scene cuts.</t>

<t>A P-frame is a frame that references on one or more earlier frames.
These frames are delta-encoded, such that they only encode the changes (typically motion).
This result in a massive file size reduction for most content outside of few notorious cases (ex. confetti).</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency can avoid reference frames to allow more to be dropped.</t>

<section anchor="appendix.b-frame" title="B-Frames">
<t>The goal of video codecs is to maximize compression.
One of the improvements is to allow a frame to reference later frames.</t>

<t>A B-frame is a frame that can reference one or more frames in the future, and any number of frames in the past.
These frames are more difficult to encode/decode as they require buffering and reordering.</t>

<t>A common encoding structure is to use B-frames in a fixed pattern.
Such a fixed pattern is not optimal, but it's simpler for hardware encoding:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its references.
This makes it easier for the decoder as all references are earlier in the bitstream and can be decoded immediately.</t>

<t>However, this causes problems with B-frames because they depend on a future frame, and some reordering has to occur.
In order to keep track of this, frames have a decode timestamp (DTS) in addition to a presentation timestamp (PTS).
A B-frame will have higher DTS value that its dependencies, while PTS and DTS will be the same for other frame types.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
PTS: I B P B P I B P B P B
DTS: I   PB  PBI   PB  PB
]]></artwork></figure>

<t>B-frames add latency because of this reordering so they are usually not used for conversational latency.</t>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is an I-frame followed by any number of frames until the next I-frame.
All frames MUST reference, either directly or indirectly, only the most recent I-frame.</t>

<figure><artwork><![CDATA[
        GoP               GoP            GoP
+-----------------+-----------------+---------------
|     B     B     |     B     B     |     B
|    / \   / \    |    / \   / \    |    / \
|   v   v v   v   |   v   v v   v   |   v   v
|  I <-- P <-- P  |  I <-- P <-- P  |  I <-- P ...
+-----------------+-----------------+--------------
]]></artwork></figure>

<t>This is a useful abstraction because GoPs can always be decoded independently.</t>

</section>
<section anchor="appendix.svc" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This layered coding means that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
      +-------------------------+------------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P ...
      +-------------------------+------------------
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.audio" title="Audio">
<t>Audio is dramatically simpler than video as it is not typically delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>The encoder spits out a continuous stream of samples (S):</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S ...
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.examples" title="Appendix B. Segment Examples">
<t>Warp offers a large degree of flexability on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of some options available.</t>

<section anchor="video" title="Video">

<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and all frames that directly or indirectly reference it (<xref target="appendix.gop"/>).
The tail of a GoP can be dropped without causing decode errors, even if the encoding is otherwise unknown, making this the safest option.</t>

<t>It is RECOMMENDED that each segment consist of a single GoP.
For example:</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

<t>Depending on the video encoding, this approach may introduce unnecessary ordering and dependencies.
A better option may be available below.</t>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy (<xref target="appendix.svc"/>).</t>

<t>When SVC is used, it is RECOMMENDED that each segment consist of a single layer and GoP.
For example:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the encoder MAY can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>For example, we could split our example B-frame structure (<xref target="appendix.b-frame"/>) into 13 segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, segments can be merged with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

</section>
<section anchor="init" title="Init">
<t>Initialization data (<xref target="appendix.init"/>) is required to initialize the decoder.
Each segment MAY start with initialization data although this adds overhead.</t>

<t>Instead, it is RECOMMENDED to create a init segment.
Each media segment can then depend on the init segment to avoid the redundant overhead.
For example:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 5
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|              init             |  init
+-------------------------------+---------
             segment 1           segment 4
]]></artwork></figure>

</section>
</section>
<section anchor="audio" title="Audio">
<t>Audio (<xref target="appendix.audio"/>) is much simpler than video so there's fewer options.</t>

<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

<t>Since video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
<section anchor="appendix.delivery-order" title="Delivery Order">
<t>The delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>The delivery order may be changed if the content changes.
For example, switching from a live stream (skippable) to an advertisement (unskippable).</t>

</section>
</section>
<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology — Coding of audio-visual objects — Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
H4sIADo2VmMAA9V96XIbSbbefzxFWv1jJA+ApqSenm723PBwUzdjRIkWqemY
sB1XiUICqGGhCl0LKbTECT+EH8DP4kfxk/isuRQKlNQ3xvblTFMEULmdPMt3
lkxMJpNRm7eFOzSPfrb1xkzMlVuuXdm6uXmZ3zpz4ea5Nde1LZtNVbePRnY2
q93tofn56M3laF5lpV1D63ltF+2kyLq6cNvJHXQ1KWzrmnY0h38OzYfTo+uz
+1EGL5ZVvT00ebmoRqN8Ux+atu6a9tnBwfcHz0a2dvbQ/OhKV9tidFfVN8u6
6jaH5rycu42DX2VrrrrZOm+avCpHN24LD83x89bVpWsnpziT0ahpbTn/V1tU
JYy+dc2oWdu6/ddfugpmdWjKarTJD81/aatsbBpYWO0WDfy1XfMfsLC13Wzy
cvnfRiPbtauqPhwZM4H/DMwdeng5NSe0WnqLqfCyu3Hxu1W9tGX+q21hqofm
+i5vsxV94NY2Lw7NTf7eIZnmf17iG9OsWo/SUf4yNZfdMi+jQf6S13lRRG+n
o1y41sZj5Dd5/ec1vDnQ+9XUvAIy2ZsOiBMNcdWtbNP/KB3mJG+yKh6nKfnx
P2f4CQ82Kqt6DQ1uHRLvP789Pzk0b16cfH9wcCCvJ2/OTl7/9ezN3/SDZ/DB
z27mGQ52dnI6zV27mNy5WYtvT1Ztu3mOSzm/en188eLFIc1D+fgcOItGrUrT
umxVVkW13Jr//d//hzmp5rCjploY283zanKbN50tTDX7u8vahh65BC4xT58d
Yt/m2DYqAS/ywpkX1PEjGo75+tnB0z9Mnj4DTtZRea0nF0efN63JxFx0RZuv
aRRguSLP+CF+3Dy+uDz7cXL0BJ/kyX0P1K/Wa3hkfyMc/wm+Mo2XZ3o6nfyz
g8nBc3jnlbt748qKNuHbP3yHm3B8/IZpn9l6fueKYpJnWb2cgPhPsqpcgmzD
gPhnW1fFBDZuNJrAHO2sgV3KQASvV3mDgtTh+GbuFnnpGtOunMmq2pmZW9nb
HGaIs0TlMzY2mm2B2ocX2CozmE1dgcRWxXTEuwIDNLD4Fti5rbRxY2awb3OD
hIbBOlAadbHFjefuXJkRH0xHZzZbaSvsiwZa5y2OnweFU2xNdetqmB6yrIH1
ObuejqIXjQHFBbOD5eRt/qubw1qKorrDQQvXNCZf4/wtDOMnCROeOWhv61uc
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

-->

</rfc>

